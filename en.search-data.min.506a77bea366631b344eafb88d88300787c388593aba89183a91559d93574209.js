'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.newdocsSearchIndex=index;index.add({'id':0,'href':'/guides/contributing-a-nep/','title':"Contributing a NEP",'section':"NEPs Guidelines",'content':"This doc was originally from https://github.com/newtonproject/NEPs/wiki and should be added to a NEP as reference.   Review NEP-0 and guidelines in this document. Fork the repository by clicking \u0026ldquo;Fork\u0026rdquo; in the top right. Add your NEP to your fork of the repository. Use a template to start your NEP. Submit a Pull Request to Newton\u0026rsquo;s NEPs repository.  Start A NEP #  We welcome anyone with suggestions related to Newton Project to compile a NEP.\nBefore you begin writing a formal NEP, you should vet your idea. Ask the Newton community first if an idea is original to avoid wasting time on something that will be be rejected based on prior research.\nIn addition to making sure your idea is original, it will be your role as the author to make your idea clear to reviewers and interested parties, as well as inviting editors, developers and community to give feedback. You should try and gauge whether the interest in your NEP is commensurate with both the work involved in implementing it and how many parties will have to conform to it. Negative community feedback will be taken into consideration and may prevent your NEP from moving past the Draft stage.\nFor more:\n  Contributing A NEP  NEP Submission Guides for Beginners  Your first PR should be a first draft of the NEP. It must meet the formatting criteria. An editor will manually review the first PR for a new NEP and assign it a number before merging it. Make sure you include a Discussions header with the URL to a discussion forum or open GitHub issue where people can discuss the NEP as a whole.\nOnce your first PR is merged, it will be merged to draft NEPs. For this to work, it has to be able to tell that you own the draft being edited. Make sure that the \u0026lsquo;authors\u0026rsquo; line of your NEP contains either your GitHub username or your email address inside . If you use your email address, that address must be the one publicly shown on your your GitHub profile.\nTo update a draft NEP, you need to created another PR after edit. Once the PR is merged, your updated draft NEP will be merged to draft NEPs.\nFinalize a draft NEP: When you believe your NEP is mature and ready to progress past the Draft phase to Final, you should do:\nOpen an issue to request for make the NEP Final. An editor will review your request and ask if anyone objects to its being finalised. If the editor decides there is no rough consensus - for instance, because contributors point out significant issues with the NEP - they may close the issue and request that you fix the issues in the draft before trying again.\nIf your request for finalised a NEP has been approved, an editor will change the NEP status to Public Call for anyone to check it can be a Final NEP. Once the Public Call period has passed. An editor will update the status to Final.\n"});index.add({'id':1,'href':'/guides/nep-submission-guide-for-beginners/','title':"NEP Submission Guides for Beginners",'section':"NEPs Guidelines",'content':"This doc was originally from https://github.com/newtonproject/NEPs/wiki and should be added to a NEP as reference.  This guide is for those unfamiliar with the NEP Process and provides simple instructions for NEP submission, update, and request for final. This guide won\u0026rsquo;t cover complex NEP status change and other requests described in NEPs Guideline.\nThis guide covers:\n  Start A NEP\n  To Submit NEP for The First Time\n  To Update a Draft NEP\n  To Make A NEP to Final / Active\n  I. Start A NEP #  You can start writing your thoughts of a NEP first. And check if your thoughts are already in the existing NEPs.\nYou can choose from the NEP templates to get started. Since you already wrote down your thoughts, try to use a template from and finish the Summary and Abstract section. If your thoughts are not formed well enough, you can choose to skip the templates and use it later.\nDiscussion with other people, try to get one or more people become your co-authors, that helps your NEP become more carefully considered. Also it is recommended to have a public discussion board from the beginning. You can choose any public discussion services such as Google Groups, Facebook Pages, or your own Github repos.\nYou can choose any text editor apps to work with. If you are more familiar with Google Docs, Apple Pages, Microsoft Word, it is okay to use them to begin with. But the formal NEP for submission requires a Mark Down format. You will need to use a NEP template later.\nII. To Submit NEP for The First Time #  All NEP submissions require to make a Pull Request(PR) from your own git repository on Github. If you haven\u0026rsquo;t forked the NEPs repository, please follow the guide below to fork the NEPs repository and add your NEP to your repository.\nFork the NEPs Repository #    You need a Github account and to be logged in\n  Click the Fork button on the upper right of the NEPs Github Page\n  You have successfully forked the NEPs repository\n  Add your NEP to your repository #    Choose a template to start with.\n  Add your NEP to NEPS/NEP-X/index.md file\n  Create Pull Request for NEP submission #  Make sure your NEP documents and assets follow the NEPs guideline. All NEPs submission not following the guideline require may get rejected.\n  Change the NEP status from WIP to Draft when it\u0026rsquo;s ready for submission\n  Perform a PR from your repository to Newton\u0026rsquo;s NEPs repository.\n  State clear you are submitting the NEP for the first time in the title.\n  Make sure to check Allow edits from maintainers\n  NEP Editor Review #    NEP Editors will review your submission.\n  If your NEP requires modifications, NEP Editors will point out and ask you to make changes in your repository.\n  If the NEP editor thinks your NEP is ready for the Review Board to review. A NEP Editor will assign a NEP number and update your documents. You can not add/change your NEP number by yourself. If you self added/changed the NEP number. The submission will be rejected.\n  NEP Board Review #    The NEP Review Board host meetings for NEP review regularly.\n  The Authors may be invited to join the meeting depending on the type or contents of your NEP.\n  If your NEP passed the review. Your NEP submission will pass and NEP Editors will include(merge) your NEP to Newton\u0026rsquo;s NEPs Repository.\n  If your NEP is good but require small changes like description, content naming space, add references to support your NEP. You should update your NEP documents. Once you have completed the change, add a reply to your PR and mention a NEP Editor to review your change. Once reviewed and the NEP Editor thinks it meets all the questions/problems from the Review Board. The NEP Editor will pass your NEP without additional review from the NEP Review Board, the NEP Editor will include(merge) your NEP to Newton\u0026rsquo;s NEPs Repository.\n  If the NEP Review Board thinks the NEP will not pass. Your submission will be rejected. And the PR will be closed. If you wish to continue on the same NEP, you can make a new PR in the future.\n  As long as your new NEP PR is talking about the same thing and you kept NEP number assigned history from the NEP Editor in your repository. You can use the same NEP number in your future submission.\n  III. To Update a Draft NEP #  You have to be one of the Author to update a NEP\nTo update a Draft NEP, you must be one of the Authors mentioned in the NEP. If you are not amount the authors, your submission will be rejected. Contact the NEP Authors you are willing to join and ask them to add you to the NEP first.\nIf you tried contact the Authors and get no response, you may ask the NEP Editors for assistance. If the NEP Editors can\u0026rsquo;t reach the NEP Authors, the editor may consider they have abandoned the NEP and change the status to abandoned. You may work on that and submit new updates to that NEP.\nOnly NEP in Active/Draft status can accept updates*\nOnce a NEP become Final. It can no longer accept changes.\nAn Active status NEP can accept updates for adding features, but other parts can not be changes.\nCreate Pull Request for NEP update submission #    Perform a PR from your repository to Newton\u0026rsquo;s NEPs repository.\n  State clear you are updating a Draft NEP in the title. E.g. \u0026ldquo;Update NEP-3\u0026rdquo;\n  Tell what have been changed to the last Draft in the descriptions.\n  Make sure to check Allow edits from maintainers\n  Review Procedure #  The review is pretty much alike to Submit your NEP for the first time. Except there may be no NEP Review Board reviews required depending on the updates of the NEP.\nIV. To Make A NEP to Final / Active #  A NEP Draft must be already in Newton NEPs repository before requesting for it to be finalised.\nCreate an Issue for NEP to be finalised #    Create an issue in Newton\u0026rsquo;s NEPs repository on Github.\n  State you want to finalised a NEP in the title. E.g. \u0026ldquo;NEP-3, request for Final\u0026rdquo;\n  Tell why you think it can be finalised in description.\n  NEP Editor Review #    NEP Editors should check the request and go through the current Draft.\n  NEP Editors should also check if the request is agreed from all the authors.\n  NEP Editors should ask the NEP Review Board to include this topic in the next meeting.\n  NEP Review Board Review #    NEP Review Board should make the decision whether the NEP can/should be finalised.\n  NEP Review Board should also giving a Public Review period. Normally 14 days, but depending of the NEP, the period may change.\n  Public Review #    If the NEP Review Board decides a NEP can be finalised, a Public Review is going to happen.\n  NEP Editors should change the NEP status to Public Call.\n  The Public Call of a NEP should be prominently listed on Newton Project\u0026rsquo;s official website.\n  Any change request to the NEP document during the Public Review will result the NEP status revert to Draft.\n  When a NEP has passed the Public Review. NEP Editors will update the status to Final/Active.\n  "});index.add({'id':2,'href':'/guides/nep-process/','title':"NEP Process",'section':"NEPs Guidelines",'content':"This doc was originally from https://github.com/newtonproject/NEPs/wiki and should be added to a NEP as reference.  Shepherding a NEP #  Parties \u0026amp; Roles involved in the process a NEP are: NEP you, the NEP Champion(Lead) or Authors, NEP Editors, NEP Review Board, and the Public Communnity.\nBefore you begin writing a formal NEP, you should vet your idea. Ask the Newton community first if an idea is original to avoid wasting time on something that will be be rejected based on prior research.\nIn addition to making sure your idea is original, it will be your role as the author to make your idea clear to reviewers and interested parties, as well as inviting editors, developers and community to give feedback. You should try and gauge whether the interest in your NEP is commensurate with both the work involved in implementing it and how many parties will have to conform to it. Negative community feedback will be taken into consideration and may prevent your NEP from moving past the Draft stage.\nGeneral NEP Flow #  General NEP Status Flow --- \u0026#34;WIP\u0026#34; -\u0026gt; \u0026#34;Draft\u0026#34; -\u0026gt; \u0026#34;Public Call\u0026#34; -\u0026gt; \u0026#34;Final / Active\u0026#34; See NEP Status for more NEP Statuses and flowchart.\nI. Submit a NEP Draft for the first time #  Follow the procedure in Contributing a NEP or NEP Submission Guides for Beginners to Start a NEP.\nOnce the NEP is ready to become a Draft, create a PR to the NEPs repository.\nView NEP Process # Submit a NEP Draft for the first time NEP_Status = \u0026#34;WIP\u0026#34; $Authors: change NEP_Status = \u0026#34;Draft\u0026#34; create PR = \u0026#34;New NEP-X Draft\u0026#34; { CHECK CONTENTS } $NEP_Editor: case Good \u0026gt;\u0026gt; { ASSIGN NUMBER } case Ready \u0026gt;\u0026gt; { BOARD REVIEW } case Require Edit request $Authors to Edit \u0026gt;\u0026gt; { CHECK CONTENTS } case Not Pass \u0026amp;\u0026amp; Will Not Continue PR = \u0026#34;Closed\u0026#34; \u0026amp;\u0026amp; exit NEP Process { ASSIGN NUMBER } $NEP_Editor: assign NEP_Number = \u0026#34;Issue/PR Number\u0026#34; update PR = \u0026#34;New NEP-# Draft\u0026#34; \u0026amp;\u0026amp; \u0026gt;\u0026gt; { CHECK CONTENTS } { BOARD REVIEW } $NEP_Review_Board: case Accept PR = \u0026#34;Merged\u0026#34; \u0026amp;\u0026amp; exit NEP Process case Deny PR = \u0026#34;Closed\u0026#34; \u0026amp;\u0026amp; exit NEP Process    II. Update a NEP Draft #    Only NEP in Draft status can accept updates\n  You have to be one of the Authors to update a NEP\n  To update a Draft NEP, you must be one of the Authors mentioned in the NEP. If you are not amount the authors, your submission will be rejected. Contact the NEP Authors you are willing to join and ask them to add you to the NEP first.\nIf you tried contact the Authors and get no response, you may ask the NEP Editors for assistance. If the NEP Editors can\u0026rsquo;t reach the NEP Authors, the editor may consider they have abandoned the NEP and change the status to abandoned. You may work on that and submit new updates to that NEP.\nView NEP Process # Update a NEP Draft NEP_Status = \u0026#34;Draft\u0026#34; $Authors: create PR = \u0026#34;Update NEP-# Draft\u0026#34; { CHECK CONTENTS } $NEP_Editor: case Ready \u0026gt;\u0026gt; { CHECK IF REVIEW REQUIRED } case Require Edit request $Authors to Edit \u0026gt;\u0026gt; { CHECK CONTENTS } case Not Pass \u0026amp;\u0026amp; Will Not Continue PR = \u0026#34;Closed\u0026#34; \u0026amp;\u0026amp; exit NEP Process { CHECK IF REVIEW REQUIRED } $NEP_Editor: case Required \u0026gt;\u0026gt; { BOARD REVIEW } case Not Requred PR = \u0026#34;Merged\u0026#34; \u0026amp;\u0026amp; exit NEP Process { BOARD REVIEW } $NEP_Review_Board: case Accept PR = \u0026#34;Merged\u0026#34; \u0026amp;\u0026amp; exit NEP Process case Deny PR = \u0026#34;Closed\u0026#34; \u0026amp;\u0026amp; exit NEP Process    III. Make a NEP Draft to NEP Final / Active #    A NEP Draft must be already in Newton NEPs repository before requesting for it to be finalised to Final / Active\n  You have to be one of the Authors to make a NEP Final / Active\n  Once a NEP become Final. It can no longer accept changes\n  Create an PR in Newton\u0026rsquo;s NEPs repository on Github\n  Tell why you think it can be finalised in description\n  If you are not amount the authors, your submission will be rejected. Contact the NEP Authors you are willing to join and ask them to add you to the NEP first.\nIf you tried contact the Authors and get no response, you may ask the NEP Editors for assistance. If the NEP Editors can\u0026rsquo;t reach the NEP Authors, the editor may consider they have abandoned the NEP and change the status to abandoned. You may work on that and submit new updates to that NEP.\nView NEP Process # Make a NEP Draft to NEP Final NEP_Status = \u0026#34;Draft\u0026#34; $Authors: change NEP_Status = \u0026#34;Public Call\u0026#34; create PR = \u0026#34;Make NEP-# Final\u0026#34; { CHECK CONTENTS } $NEP_Editor: case Ready \u0026gt;\u0026gt; { BOARD REVIEW } case Not Pass \u0026amp;\u0026amp; Will Not Continue PR = \u0026#34;Closed\u0026#34; \u0026amp;\u0026amp; exit NEP Process { BOARD REVIEW } $NEP_Review_Board: case Accept PR = \u0026#34;Merged\u0026#34; \u0026amp;\u0026amp; \u0026gt;\u0026gt; { PUBLIC REVIEW } case Deny PR = \u0026#34;Closed\u0026#34; \u0026amp;\u0026amp; exit NEP Process { PUBLIC REVIEW } case Accept NEP_Status = \u0026#34;Final\u0026#34; \u0026amp;\u0026amp; exit NEP Process case Deny NEP_Status = \u0026#34;Draft\u0026#34; \u0026amp;\u0026amp; exit NEP Process    IV. Update an Active NEP #    You have to be one of the Authors to update an Active NEP\n  An Active status NEP can accept updates for adding features, but other parts can not be changes\n  View NEP Process # Update an Active NEP NEP_Status = \u0026#34;Active\u0026#34; $Authors: create PR = \u0026#34;Update Active NEP-#\u0026#34; { CHECK CONTENTS } $NEP_Editor: case Ready \u0026gt;\u0026gt; { CHECK IF REVIEW REQUIRED } case Require Edit request $Authors to Edit \u0026gt;\u0026gt; { CHECK CONTENTS } case Not Pass \u0026amp;\u0026amp; Will Not Continue PR = \u0026#34;Closed\u0026#34; \u0026amp;\u0026amp; exit NEP Process { CHECK IF REVIEW REQUIRED } $NEP_Editor: case Required \u0026gt;\u0026gt; { BOARD REVIEW } case Not Requred PR = \u0026#34;Merged\u0026#34; \u0026amp;\u0026amp; exit NEP Process { BOARD REVIEW } $NEP_Review_Board: case Accept PR = \u0026#34;Merged\u0026#34; \u0026amp;\u0026amp; exit NEP Process case Deny PR = \u0026#34;Closed\u0026#34; \u0026amp;\u0026amp; exit NEP Process    Special NEP Flow #  Special NEP Status Flow --- \u0026#34;Draft\u0026#34; -\u0026gt; \u0026#34;Abandoned\u0026#34; -\u0026gt; \u0026#34;Draft\u0026#34; \u0026#34;Final\u0026#34; -\u0026gt; \u0026#34;Implemented\u0026#34; \u0026#34;Final\u0026#34; -\u0026gt; \u0026#34;Deferred\u0026#34; -\u0026gt; \u0026#34;Implemented\u0026#34; \u0026#34;Final\u0026#34; / \u0026#34;Implemented\u0026#34; -\u0026gt; \u0026#34;Superseded\u0026#34; \u0026#34;Draft\u0026#34; -\u0026gt; \u0026#34;Rejected\u0026#34; Flow of Abandoned NEP #  See Transferring NEP Ownership.\nNEP Final become Implemented or Deferred #  tbd\nNEP Got Superseded #  tbd\nRejected NEP #  tbd\n"});index.add({'id':3,'href':'/guides/format/','title':"NEP Format and Templates",'section':"NEPs Guidelines",'content':"This document will cover:\n NEP Document Directory NEP Templates NEP Header Preamble NEP Content Format  I. NEP Document Directory #  // NEPs Document Directory ./ └─ NEPS/ | └─ nep-x/ // `x` is the NEP Number | | ├─ index.md // main NEP Document in English | | ├─ index.zh.md // main NEP Document in Chinese | | ├─ image1.png // image used in NEP | | ├─ image2.jpg // image used in NEP | | └─ filename.ext // file used in NEP | └─ nep-template/ // this is the NEP Template Folder NEP Document File #  NEP Doument file is index.md file in it\u0026rsquo;s directory.\nEvery NEP should starts with the English version first. Each translation is translated from that English and placed in a new file using index.lang.md format.\nAuxiliary Files #  If your NEP requires images, the image files should be included in the same directory of that NEP. When linking to an image in the NEP, use relative links such as image.png. Other files should follow the same pattern.\n  When linking files from another NEP, it is enforced to copy that file from reference NEP directory to the working NEP directory.\n  Files of jpg, jpeg, png, svg format are generally accepted.\n  Files of html, js and other server-side or browser-side executable format are not accepted.\n  If you must include an executable file like js, change the extension to txt instead.\n  II. NEP Templates #  // NEP Template Directory ./ └─ NEPS/ | └─ nep-template/ // this is the General NEP Template Folder | | └─ index.md // this is the General NEP Template Document | └─ nep-template-nrc/ // this is the NRC Type NEP Template Folder | | └─ index.md // this is the NRC Type NEP Template Document | └─ nep-x/ // your NEP-X Folder | | └─ index.md // your NEP-X Document To use the NEP Template, copy nep-template folder to nep-x folder and start your NEP with nep-x/index.md.\nCurrent available templates:\n  General NEP Template /NEPS/nep-template/\n  NEP Template for Token (NRC) /NEPS/nep-template-nrc/\n  III. NEP Header Preamble #  Here is an example of NEP Header Preamble, all fields listed in this example are required.\n--- NEP: X Title: \u0026#34;This is the NEP Title\u0026#34; Authors: \u0026#34;[First Last](mailto:name@domain.ext)\u0026#34; Discussions: https://url.to.discussions.ext Status: Draft Categories: Economic Model Created: YYYY-MM-DD --- # NEP Content Starts 1. NEP #  NEP: X   required\n  NEP number (this is determined by the NEP editor)\n  2. Title #  Title: \u0026#34;This is the NEP Title\u0026#34;   required\n  NEP title quoted with \u0026quot; \u0026quot;\n  3. Authors #  Authors: \u0026#34;[First Last](mailto:name@domain.ext)\u0026#34;   required\n  A list of the author’s or authors’ name(s) and/or username(s), or name(s) and email(s). Details are below.\n  Authors Code Examples # Author with Email Authors: \u0026#34;[First Last](mailto:name@domain.ext)\u0026#34; # Author with URL Authors: \u0026#34;[First Last](https://domain.ext)\u0026#34; # Multiple Authors Authors: \u0026#34;[Author 1](author1:name@domain.ext), [Author 2](https://author2.ext), [Author 3](mailto:aurhtor3@domain.ext)\u0026#34;    4. Discussions #  Discussions: https://url.to.discussions.ext   required\n  While an NEP is a draft, a discussions-to header will indicate the mailing list or URL where the NEP is being discussed.\n  No Discussions header is necessary if the NEP is being discussed privately with the author and haven\u0026rsquo;t been submitted to NEPs repo yet.\n  Discussions cannot point to GitHub pull requests.\n  5. Status #  Status: Draft   required\n  WIP, Draft, Public Call, Final etc.\n  See NEP Status for all available status\n  6. Categories #  Categories: Economic Model   required\n  NEP currently has 5 categories: Economic Model, Personnel, Technical, Community Governance and Business\n  This is defined by NEP-0: NEP Genesis.\n  7. Created #  Created: YYYY-MM-DD   required\n  Date for first created in YYYY-MM-DD format\n  8. Updated #  Updated: YYYY-MM-DD   Comma separated list of dates.\n  e.g. 2020-12-23 or 2020-10-01, 2020-05-14, 2019-12-31\n  9. Types #  Types: Standard  NEP currently has 3 types: Standard, NRC and Informational  10. SupersededBy #  SupersededBy: 100   The NEP Number of NEP that superseded this NEP.\n  Only NEPs moved to Active, Final and later status can be added as an SupersededBy item.\n  11. Superseding #  Superseding: 50   The NEP Number of NEP that is or is to be superseded by this NEP\n  Only NEPs moved to Active, Final and later status can be added to this field.\n  This field should be added since this NEP is meant to supersede another NEP, even when this NEP is still in WIP status.\n  Last, Ordering #  The order of NEP Header Preamble Item is not enforced, but it is recommended to use the order as the example below:\n0 1 2 3 4 5 6 7 8 9 10 11 12 13  --- NEP: Title: Authors: Discussions: Status: SupersededBy: Superseding: Categories: Types: Created: Updated: --- # NEP Content Starts   IV. NEP Content Format #  NEP Content should be written in Markdown format. Markdown formatting is widely used in websites and documents, also there were dozens of implementations in many languages and software applications.\nCommonMark Spec is a standard for Markdown and adopted by many applications. To see the latest CommonMark Spec please visit https://spec.commonmark.org.\nWe\u0026rsquo;ll provide more format examples in this document later.\n"});index.add({'id':4,'href':'/guides/nep-status/','title':"NEP Status",'section':"NEPs Guidelines",'content':"This doc was originally from https://github.com/newtonproject/NEPs/wiki and should be added to a NEP as reference.  I. Available NEP Statuses #  Statuses listed below is the Standard NEP Status for Newton Evolution Proposals.\nRegular Statuses #   WIP Draft Public Call Final Implemented  Special Statuses #  Deferred Superseded Active Abandoned Rejected  II. Status Definations #  Each status change is requested by the NEP author and reviewed by the NEP editors. Use a pull request to update the status. Please include a link to where people should continue discussing your NEP. The NEP editors will process these requests as per the conditions below.\n1. WIP(Work In Progress) #  WIP: Work In Progress is the status before a NEP is submitted to Newton for review. The champion can use other status name such as an IDEA to share the NEP for discussion outside Newton\u0026rsquo;s Github repository.\nWIP \u0026ndash;\u0026gt; Draft #   Once the champion has finished a NEP and consider it\u0026rsquo;s ready to be merged to Newton\u0026rsquo;s Github repository. they will write a draft NEP as a pull request. Consider including an implementation if this will aid people in studying the NEP.  2. Draft #  Draft: If the draft is agreeable amount the Newton community, NEP editor will assign the NEP a number (generally the issue or PR number related to the NEP) and merge your pull request. The NEP editor will not unreasonably deny an NEP.\nDraft -\u0026gt; update Draft #   Once the first draft has been merged, you may submit follow-up pull requests with further changes to your draft until such point as you believe the NEP to be mature and ready to proceed to the next status.  Draft -\u0026gt; Public Call #    ✅: If agreeable, the NEP editor will assign Public Call status and set a review end date (review-period-end), normally 14 days later.\n  ❌ -\u0026gt; Draft: A request for Public Call status will be denied if material changes are still expected to be made to the Draft. We hope that NEPs only enter Public Call once, so as to avoid unnecessary resource.\n  Draft -\u0026gt; Rejected #   See Rejected status.  Draft -\u0026gt; Abandoned #   See Abandoned status.  3. Public Call #  Public Call: This NEP will listed prominently on the https://newtonproject.org/nep website.\nPublic Call -\u0026gt; Active / Final #    ✅: A successful Public Call without material changes or unaddressed technical complaints will become Final.\n  ❌ -\u0026gt; Draft: A Public Call which results in material changes or substantial unaddressed technical complaints will cause the NEP to revert to Draft.\n  4. Final #  Final: This NEP represents the current state-of-the-art. A Final NEP should only be updated to correct errata.\nFinal -\u0026gt; Implemented #   See Implemented status.  Final -\u0026gt; Deferred #   See Deferred status.  Final -\u0026gt; Superseded #   See Superseded status.  5. Implemented #  Implemented: Some NEP is required one-time only implementation to meets the NEP\u0026rsquo;s to be completed. Once the implementation is complete, the status will be changed to \u0026ldquo;Implemented\u0026rdquo; by an editor. Only NEPs with status Final can be changed to Implemented.\nImplemented -\u0026gt; Superseded #   See Superseded status.  6. Deferred #  Deferred: An NEP with plan to be Implemented will become Deferred if haven\u0026rsquo;t met the criteria to be marked as Implemented.\n7. Superseded #  Superseded: An NEP which was previously Final but is no longer considered state-of-the-art. Another NEP will be in Final status and reference the Superseded NEP. An NEP cannot move on from this state.\n8. Active #  Active: Some Informational and Process NEP may also have a status of Active if they are never meant to be completed.\n9. Abandoned #  Abandoned: This NEP is no longer pursued by the original authors or it may not be a preferred option anymore.\nAbandoned -\u0026gt; Draft #   Authors or new champions wishing to pursue this NEP can ask for changing it to Draft status.  10. Rejected #  Rejected: An NEP that is fundamentally broken. An NEP cannot move on from this state.\nIII. Flowchart #   mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph TD AuthorEdit[Authors' Edit] -- |PR| Draft subgraph \"NEP Review Process\" Draft -- Rejected Draft -- PublicCall[Public Call] Draft -- Abandoned Abandoned -- Draft end PublicCall -- PublicCall_Merged[Public Call] PublicCall_Merged -- Draft PublicCall_Merged -- Final PublicCall_Merged -- Active subgraph \"Status Change on Conditions\" Final -- Deferred Deferred -- Implemented Final -- Implemented Deferred -- Superseded Implemented -- Superseded Final -- Superseded end subgraph \"NEP Review Process\" Active -- |PR| Active end "});index.add({'id':5,'href':'/guides/nep-editors/','title':"NEP Editors",'section':"NEPs Guidelines",'content':"This doc was originally from https://github.com/newtonproject/NEPs/wiki and should be added to a NEP as reference.  NEP Editors Responsibilities #  For each new NEP that comes in, an editor does the following:\n Read the NEP to check if it is ready: sound and complete. The ideas must make technical sense, even if they don\u0026rsquo;t seem likely to get to final status. The title should accurately describe the content. Check the NEP for language (spelling, grammar, sentence structure, etc.), markup (GitHub flavored Markdown), code style etc.  If the NEP isn\u0026rsquo;t ready, the editor will send it back to the author for revision, with specific instructions.\nOnce the NEP is ready for the repository, the NEP editor will:\n  Assign an NEP number (generally the PR number or, if preferred by the author, the Issue # if there was discussion in the Issues section of this repository about this NEP)\n  Merge the corresponding pull request\n  Send a message back to the NEP author with the next step.\n  Many NEPs are written and maintained by developers with write access to the Newton codebase. The NEP editors monitor NEP changes, and correct any structure, grammar, spelling, or markup mistakes we see.\nThe editors don\u0026rsquo;t pass judgment on NEPs. We merely do the administrative \u0026amp; editorial part.\nCurrent NEP editors #     GitHub ID NEW Address      @liuyong5653 NEW182VbmZs3TyC268wz7Kq4Cznssv7WzRPDq7j    @weixuefeng NEW182PdJBJoMnGAub6KJ6YrhSPHWrFE9RSBmGE    @zhouxiqiao NEW182Vzd7pgjGjNCKVB7831yFCT5yuhSfRnfgA    "});index.add({'id':6,'href':'/guides/nep-review-board/','title':"Review Board",'section':"NEPs Guidelines",'content':"This doc was originally from https://github.com/newtonproject/NEPs/wiki and should be added to a NEP as reference.  Current Review Board Members #     Display Name GitHub ID NEW Address     Mr. Koo  @benkoo NEW182XacauX8woduncHaXTzNGCFnk7B15z34hi   Evan Liu  @evanliuchina NEW182Jqu3ok6ZnjkLAyhpSw9WEJXhEwUYX4jLR   Qu Jianwei  @i29 NEW182TpZToiXBk1SkR1bMJLUxguPxFsZciz123   Jiang Tao  @jiangtao-tang NEW182XmN8jkgnkW8rtu9jRriQJjnEBXSbZZuHJ   Lee Willson  @leewillson NEW182ZheiEbSBW3SbtETmXEgdG5X9GvFuLRun2   VieYang  @VieYang NEW182bMUiAM1nXMjcwri8zNrgZftcnPJc1uVie   xiawu  @xiawu NEW182Kt8siZGciPGBss3rg7GmJqfZ7CUafVUHH   Xu Jizhe  @xujizhe unregistered   zqy15789  @zqy15789 NEW182EFjxZjxRJcfBdJBHEuMTYNsK7RLTFeiiJ    "});index.add({'id':7,'href':'/guides/transfer-nep-ownership/','title':"Transferring NEP Ownership",'section':"NEPs Guidelines",'content':"This doc was originally from https://github.com/newtonproject/NEPs/wiki and should be added to a NEP as reference.  It occasionally becomes necessary to transfer ownership of NEPs to a new champion. In general, we’d like to retain the original author as a co-author of the transferred NEP, but that’s really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the NEP process, or has fallen off the face of the net (i.e. is unreachable or isn’t responding to email). A bad reason to transfer ownership is because you don’t agree with the direction of the NEP. We try to build consensus around an NEP, but if that’s not possible, you can always submit a competing NEP.\nIf you are interested in assuming ownership of an NEP, send a message asking to take over, addressed to both the original author and the NEP editor. If the original author doesn’t respond to email in a timely manner, the NEP editor will make a unilateral decision (it’s not like such decisions can’t be reversed).\n"});index.add({'id':8,'href':'/reviews/nep-review-0003/','title':"NEP Board Review 0003",'section':"Reviews",'content':"Results #     NEP No. Type Start/End Block Accepts Denies Rejects Result     NEP-12 update Draft 15756530/15876529 7 0 0 Accept   NEP-20 new Draft 15756497/15876496 7 0 0 Accept   NEP-21 new Draft 15756503/15876502 7 0 0 Accept   NEP-22 new Draft 15756508/15876507 7 0 0 Accept   NEP-23 new Draft 15756516/15876515 7 0 0 Accept   NEP-24 new Draft 15756523/15876522 7 0 0 Accept    Details #     Role Github ID NEW ADDR. NEP-12 NEP-20 NEP-21 NEP-22 NEP-23 NEP-24     NEP Editor  @arisac NEW182LTNoiufc9tiveZdno3HXH5yEmUURKUiac update Draft NewExplorer new Draft NewExplorer new Draft NewExplorer new Draft NewExplorer new Draft NewExplorer new Draft NewExplorer   NEP Board Member  @benkoo NEW182XacauX8woduncHaXTzNGCFnk7B15z34hi Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @evanliuchina NEW182Jqu3ok6ZnjkLAyhpSw9WEJXhEwUYX4jLR Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @i29 NEW182TpZToiXBk1SkR1bMJLUxguPxFsZciz123 Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @jiangtao-tang NEW182XmN8jkgnkW8rtu9jRriQJjnEBXSbZZuHJ Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @leewillson NEW182ZheiEbSBW3SbtETmXEgdG5X9GvFuLRun2 Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @VieYang NEW182bMUiAM1nXMjcwri8zNrgZftcnPJc1uVie Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @xiawu NEW182Kt8siZGciPGBss3rg7GmJqfZ7CUafVUHH         NEP Board Member  @xujizhe unregistered         NEP Board Member  @zqy15789 NEW182EFjxZjxRJcfBdJBHEuMTYNsK7RLTFeiiJ Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer    Notice #  NEPs to review: NEP-20, NEP-21, NEP-22, NEP-23, NEP-24, NEP-12\n  NEP Editors  NEP Board Members NEPs Github repository: link NEPs Gitter Chatroom: link NEPs Voting Addr.: NEW182N1aGYZAHMZAFAuaahwSDVrMXJsmypNEPS NEPs Voting Demo Video: English ver link  NEP-20 #   NEP 20: Newton Encoded Asset Transaction (NEAT) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-20.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-20 Draft 0@15756496  NEP-21 #   NEP 21: Newton Physical Asset (NPA) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-21.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-21 Draft 0@15756502  NEP-22 #   NEP 22: Newton Composite Asset (NCA) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-22.md Voting Decisions: accept / deny / reject Voting Note: decision NEP-22 Draft 0@15756507  NEP-23 #   NEP 23: NEAT Backed Currency (NBC) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-23.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-23 Draft 0@15756515  NEP-24 #   NEP 24: Newton Pre-paid Card (NPC) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-24.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-24 Draft 0@15756522  NEP-12 #   NEP 12: NewORG Standard (NRC-12) Type: update Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/3cf6f9b720b2ea52eeea3d95eb0d44e19a8f8fa1/NEPS/nep-12.md Voting Decisions: accept / deny / reject Voting Note: decision update NEP-12 Draft 0@15756529  "});index.add({'id':9,'href':'/reviews/nep-review-0002/','title':"NEP Board Review 0002",'section':"Reviews",'content':"Results #     NEP No. Type Accepts Denies Rejects Final Result     NEP-19 new Draft 5 0 0 Accept    Details #     Role Github ID NEW ADDR. NEP-19     NEP Editor  @arisac NEW182LTNoiufc9tiveZdno3HXH5yEmUURKUiac new Draft NewExplorer   NEP Board Member  @benkoo NEW182XacauX8woduncHaXTzNGCFnk7B15z34hi    NEP Board Member  @evanliuchina NEW182Jqu3ok6ZnjkLAyhpSw9WEJXhEwUYX4jLR    NEP Board Member  @i29 NEW182TpZToiXBk1SkR1bMJLUxguPxFsZciz123 Accept NewExplorer   NEP Board Member  @jiangtao-tang NEW182XmN8jkgnkW8rtu9jRriQJjnEBXSbZZuHJ Accept NewExplorer   NEP Board Member  @leewillson NEW182ZheiEbSBW3SbtETmXEgdG5X9GvFuLRun2 Accept NewExplorer   NEP Board Member  @VieYang NEW182bMUiAM1nXMjcwri8zNrgZftcnPJc1uVie Accept NewExplorer   NEP Board Member  @xiawu NEW182Kt8siZGciPGBss3rg7GmJqfZ7CUafVUHH    NEP Board Member  @xujizhe unregistered    NEP Board Member  @zqy15789 NEW182EFjxZjxRJcfBdJBHEuMTYNsK7RLTFeiiJ Accept NewExplorer    Notice #  Voting Period: 2020-06-04 12:00 UTC+8 to 2020-06-05 13:00 UTC+8\nNEPs to review: NEP-19\n Voting Address: NEW182N1aGYZAHMZAFAuaahwSDVrMXJsmypNEPS NEPs Github repository: link NEPs Gitter Chatroom: link NEPs Voting Demo Video: English ver link  NEP-19 #   NEP-19: Physical Commodity Standard (NRC-19) Type: new Draft NEP Editor: @ arisac Review URL: https://github.com/newtonproject/NEPs/blob/96918c156537be45d05dbdb3cd74baa551c0bd78/NEPS/nep-19.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-19 Draft 0@153788199/NEPS/nep-12.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-12 Draft 0@14600811  "});index.add({'id':10,'href':'/reviews/nep-review-0001/','title':"NEP Board Review 0001",'section':"Reviews",'content':"Results #     NEP No. Type Accepts Denies Rejects Final Result     NEP-6 new Draft 6 0 0 Accept   NEP-7 new Draft 6 0 0 Accept   NEP-10 new Draft 6 0 0 Accept   NEP-12 new Draft 5 0 0 Accept    Details #     Role Github ID NEW ADDR. NEP-6 NEP-7 NEP-10 NEP-12     NEP Editor  @arisac NEW182LTNoiufc9tiveZdno3HXH5yEmUURKUiac   new Draft View on NewExplorer new Draft View on NewExplorer   NEP Editor  @liuyong5653 NEW182VbmZs3TyC268wz7Kq4Cznssv7WzRPDq7j new Draft View on NewExplorer      NEP Editor  @weixuefeng NEW182PdJBJoMnGAub6KJ6YrhSPHWrFE9RSBmGE  new Draft View on NewExplorer     NEP Board Member  @benkoo NEW182XacauX8woduncHaXTzNGCFnk7B15z34hi       NEP Board Member  @evanliuchina NEW182Jqu3ok6ZnjkLAyhpSw9WEJXhEwUYX4jLR Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @i29 NEW182TpZToiXBk1SkR1bMJLUxguPxFsZciz123 Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @jiangtao-tang NEW182XmN8jkgnkW8rtu9jRriQJjnEBXSbZZuHJ Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @leewillson NEW182ZheiEbSBW3SbtETmXEgdG5X9GvFuLRun2 Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @VieYang NEW182bMUiAM1nXMjcwri8zNrgZftcnPJc1uVie Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @xiawu NEW182Kt8siZGciPGBss3rg7GmJqfZ7CUafVUHH       NEP Board Member  @xujizhe unregistered       NEP Board Member  @zqy15789 NEW182EFjxZjxRJcfBdJBHEuMTYNsK7RLTFeiiJ Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer     Notice #  Voting Period: 2020-05-08 12:00 UTC+8 to 2020-05-09 12:00 UTC+8\nNEPs to review: NEP-6, NEP-7, NEP-10, NEP-12\n Voting Address: NEW182N1aGYZAHMZAFAuaahwSDVrMXJsmypNEPS NEPs Github repository: link NEPs Gitter Chatroom: link NEPs Voting Demo Video: English ver link  NEP-6 #   NEP-6: Basic Token Standard (NRC-6) Type: new Draft NEP Editor: @ liuyong5653 Review URL: https://github.com/newtonproject/NEPs/blob/c5f360f6b97284169272000de1746d94c5a8413d/NEPS/nep-6.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-6 Draft 0@14599984  NEP-7 #   NEP-7: Non-Fungible Token Standard (NRC-7) Type: new Draft NEP Editor: @ weixuefeng Review URL: https://github.com/newtonproject/NEPs/blob/35dd524fec74ac35e0f2f864f9a45ec85956188b/NEPS/nep-7.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-7 Draft 0@14599885  NEP-10 #   NEP-10: Invoice-Token-Standard (NRC-10) Type: new Draft NEP Editor: @ arisac Review URL: https://github.com/newtonproject/NEPs/blob/884ce96408b1238875c50d1e3290ad4c15b6f768/NEPS/nep-10.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-10 Draft 0@14600736  NEP-12 #   NEP-12: NewORG Standard (NRC-12) Type: new Draft NEP Editor: @ arisac Review URL: https://github.com/newtonproject/NEPs/blob/be245afa36c23189fe4b03243f4f19713eb52319/NEPS/nep-12.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-12 Draft 0@14600811  "});index.add({'id':11,'href':'/neps/nep-6/','title':"Basic Token Standard (NRC-6)",'section':"NEPs",'content':"Simple Summary #  A standard interface for tokens.\nAbstract #  The following standard allows for the implementation of a standard API for tokens within smart contracts. This standard provides basic functionality to transfer tokens, as well as allow tokens to be approved so they can be spent by another on-chain third party.\nMotivation #  A standard interface allows any tokens on NewChain to be re-used by other applications: from wallets to decentralized exchanges.\nSpecification #  Meta Data #     Item Description Behaviors/Properties     name Name of token    symbol Symbol of token    decimals decimals of Token    totalSupply Total supply of Token     Interaction / Functions #     Function Description Behaviors/Properties     transfer(recipient, amount) Moves amount tokens from the caller\u0026rsquo;s account to recipient    approve(spender, amount) Sets amount as the allowance of spender over the caller\u0026rsquo;s tokens    transferFrom(sender, recipient, amount) Moves amount tokens from sender to recipient    Query     balanceOf(account) Returns the amount of tokens owned by account    allowance(owner, spender) Returns the remaining number of tokens that spender is allowed to spend from owner    Events     Transfer(from, to, value) Emitted when value tokens are moved from one account (from) to another (to).    Approval(owner, spender, value) Emitted when the allowance of a spender for an owner is set by a call to {approve}     Rationale (optional) #  TBD\nTest Cases (optional) #  TBD\nImplementation (optional) #  interface INRC6 { /** * @dev Returns the amount of tokens in existence. */ function totalSupply() external view returns (uint256); /** * @dev Returns the amount of tokens owned by `account`. */ function balanceOf(address account) external view returns (uint256); /** * @dev Moves `amount` tokens from the caller\u0026#39;s account to `recipient`. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ function transfer(address recipient, uint256 amount) external returns (bool); /** * @dev Returns the remaining number of tokens that `spender` will be * allowed to spend on behalf of `owner` through {transferFrom}. This is * zero by default. * * This value changes when {approve} or {transferFrom} are called. */ function allowance(address owner, address spender) external view returns (uint256); /** * @dev Sets `amount` as the allowance of `spender` over the caller\u0026#39;s tokens. * * Returns a boolean value indicating whether the operation succeeded. * * IMPORTANT: Beware that changing an allowance with this method brings the risk * that someone may use both the old and the new allowance by unfortunate * transaction ordering. One possible solution to mitigate this race * condition is to first reduce the spender\u0026#39;s allowance to 0 and set the * desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * * Emits an {Approval} event. */ function approve(address spender, uint256 amount) external returns (bool); /** * @dev Moves `amount` tokens from `sender` to `recipient` using the * allowance mechanism. `amount` is then deducted from the caller\u0026#39;s * allowance. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); /** * @dev Emitted when `value` tokens are moved from one account (`from`) to * another (`to`). * * Note that `value` may be zero. */ event Transfer(address indexed _from, address indexed _to, uint256 _value); /** * @dev Emitted when the allowance of a `spender` for an `owner` is set by * a call to {approve}. `value` is the new allowance. */ event Approval(address indexed _owner, address indexed _spender, uint256 _value); } References #   ERC-20 https://eips.ethereum.org/EIPS/eip-20  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':12,'href':'/neps/nep-26/','title':"Boom: EVM and Protocol Upgrades",'section':"NEPs",'content':"Simple Summary #  Enable the outstanding Ethereum Foundation Constantinople, St. Petersburg and Istanbul network protocol upgrades on the NewChain network in a hard-fork code-named Boom to enable maximum compatibility across these networks.\nAbstract #  Add support for a subset of protocol-impacting changes introduced in the Ethereum Foundation (ETH) network via the Constantinople, St. Petersburg and Istanbul hardforks. The proposed changes for NewChain\u0026rsquo;s Boom upgrade include:\n Bitwise shifting instructions in EVM Skinny CREATE2 EXTCODEHASH opcode Net gas metering for SSTORE without dirty maps Add Blake2 compression function F precompile Reduce alt_bn128 precompile gas costs Add ChainID opcode Repricing for trie-size-dependent opcodes Calldata gas cost reduction Rebalance net-metered SSTORE gas cost with consideration of SLOAD gas cost change  This document proposes the following blocks at which to implement these changes in the NewChain networks:\n 17181218 on NewChain testnet (2020-08-08 08:06:26 UTC+8) 18500000 on NewChain mainnet (2020–09–20 20:59:42 UTC+8)  For more information on the opcodes and their respective EIPs and implementations, please see the Specification section of this document.\nMotivation #  To enhance the Ethereum Virtual Machine\u0026rsquo;s (EVM) capabilities, various opcodes shall be added to the NewChain networks, all of which have been in use on the Ethereum Foundation networks.\nSpecification #  Technical specifications for each EIP can be found at those documents respectively:\n  EIP-145: Bitwise shifting instructions in EVM  EIP-1014: Skinny CREATE2  EIP-1014: EXTCODEHASH opcode  EIP-1283: Net gas metering for SSTORE without dirty maps  EIP-152: Add Blake2 compression function F precompile  EIP-1108: Reduce alt_bn128 precompile gas costs  EIP-1344: Add ChainID opcode  EIP-1884: Repricing for trie-size-dependent opcodes  EIP-2028: Calldata gas cost reduction  EIP-2200: Rebalance net-metered SSTORE gas cost with consideration of SLOAD gas cost change  Implementation #  Adoption of the content of this NEP requires a hard fork as it introduces changes that are not backward compatible.\nThe newchain implement this features currently and would be able to support the Boom upgrade.\nCopyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':13,'href':'/neps/nep-40/','title':"Change On Community NEW Budget Plan",'section':"NEPs",'content':"Simple Summary #  To advance the NewChain development, the budget plan of the NEW release for the community (60% of 100B total supply) will be changed as described below. The release plan and curve will be the same as established.\nMotivation #  Newton has a release plan of 60B NEW to help the community develop. Since the project launched, the released NEW has been allocated to only one project, the current NewPay Community Node mining (Proof-of-Stake). To better grow the value of Newton as well as activate the community, here we propose a program called Newton Incentive Program to allocate budgets from the coming year release to support more mining projects in such aspects:\n to subsidize main-net machine nodes for realizing the opening of Newton ledgering network. to have more LPs (Liquidity Providers) for build a better liquidity, especially NEW/NUSDT, in NewSwap, for attracting more trades from centralized exchange (Huobi, etc) to our own on-chain exchange. to encourage community transferring their original Proof-of-Stake mining in NewPay to liquidity mining with their own community token in NewSwap, which will greatly help improving the value of Newton.  The first step and goal for the incentive program is to plan the budget of the coming year from the release plan, which is kept unchanged. If it works well in practice, there would be following programs in the next year and after, which will be decided later by the future community governance.\nAbstract #  The total supply of NEW is 100B, 60% of which is subjected to the community.\nIt can be divided into three parts as below:\n release will be implemented before 2021/2/1: 1545232707.3505096555 NEW one year budget (2021/2/1-2022/1/31) for incentives: 875130267.8946381786 NEW the rest: 57579637024.7548521659 NEW (will be decided by the future community governance)  The seconds part will be used for supporting the Newton Incentive Program.\nNewton Incentive Program #  The current NewPay node stake mining will be smoothly transitioned since 2021/2, then a Newton Incentive Program will be initiated:\nProgram budget: the same as above, No. 2\nThemes:\n   No Mining Theme Incentivized Behavior Budget Cap     1 Machine node Ledgering 20% (175026053.57892763572 NEW)   2 Pre-existing NewPay Community Node mining Maintaining community no less than 20% (175026053.57892763572 NEW)*   3 Liquidity mining for Community Token (cToken/NEW) Issuing tokens 30% (262539080.36839145358 NEW)   4 Liquidity minining for mainstream assets, such as NEW/NUSDT Providing liquidity 30% (262539080.36839145358 NEW)    The concrete allocation of the above budget will be laterly announced by each different implementation projects.\n*Comments: The pre-existing NewPay Community Node mining rewards will be continued. When one of the implementation projects of the Incentive Program is launched, its budget will be allocated from the total budget, and no more than the budget cap as listed above, that means the NewPay Community Node mining rewards will be reduced the same amount as allocated since then but guaranteed to be never less than 25%.\nImplementation #  Adoption of the content of this NEP requires the following phases:\nPhase 0. Preparation.\n Launch of NewBridge. Launch of NewSwap LP mining of mainstream assets.  Phase 1. Execution.\nExecute NEP-29 NewPay Community Node Migration.\nCopyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':14,'href':'/neps/nep-43/','title':"Change On Community Node NEW Unlocking Period",'section':"NEPs",'content':"Simple Summary #  This proposal changes the Community Node NEW unlocking period from 14 days to 7 days for owners and partners to unlock their staked NEW. Making the unlocking period the same as voters to unlock their staked NEW.\nAbstract #  In NewPay App, unlock NEW for Community Node owners/partners from their staked NEW will be changed from 14 days to 7 days to help them to get their NEW back faster. This requires changes to be made in NewPay App and related protocols and services.\nMotivation #  NewChain MainNet Nodes are open to the public to join after NEP-27 was proposed. And Newton Incentive Program was proposed in NEP-40, which creates more possibilities for the community to participates in the Newton eco-system and benefits from that.\nBefore NEP-27 and NEP-40, the majority community to get benefits from Newton Incentives was done by participating in Community Node Program in NewPay App. However, the Community Nodes management has to be done in NewPay App which runs on rules before NEP-27 and NEP-40 was proposed. Currently for Community Node owners/partners to unlock staked NEW to participate in other Newton Incentive Programs require 14 days, this reduces the flow of NEW in the whole Newton eco-system, also it creates inequality between the Community Node owners/partners and Community Node Voters to unlock their NEW.\nThis NEP is to reduce the complexities in Community Node management in NewPay App, make equality to all Community Node participants to unlock their NEW. As a result to encourage Community Node participants to use their NEW to participate in more Newton Incentive Programs.\nSpecification #  The unlocking period for Community Node will be set for 7 days for:\n Community Node owners to unlock staked NEW by reducing the locked amount, quitting Community Node. Community Node partners to unlock staked NEW by reducing the locked amount. Community Node voters to unlock staked NEW by reducing the locked amount.  This may be changed in the future by another NEP superseding this NEP.\nImplementation #  This proposal is planned to be implemented on:\n NewChain Testnet: 2021-03-17 NewChain Mainnet: 2021-03-19  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':15,'href':'/neps/nep-51/','title':"Changes On Community NEW Budget Plan for 2022",'section':"NEPs",'content':"Simple Summary #  Referring to NEP-40, the NEW release schedule for 2022 is now planned. The overall release curve is the same as the established one.\nMotivation #  To better enhance the value of Newton and activate the community, the NEW release for 2022 is now planned according to NEP-40. According to NEP-45, ledger nodes will have incentives. In the past year, the ledger nodes have served to protect the network.\nCurrently, there are 69 active NEW DAOs on Newton, which enrich Newton\u0026rsquo;s community building and eco-governance. The incentives for NEW DAO will be maintained in 2022.\nTo better improve the mobility of NEW and the richness of Newton\u0026rsquo;s ecology, the incentives for NewBridge and NewMall will be increased.\nAbstract #  According to NEP-40, the total releases in 2022 (2022/02/01-2023/01/31) are: 914360876.9256546229 NEW.\nThe release plan for each part is as follows:\n   No Mining Theme Incentivized Behavior Budget Cap     1 Machine node Ledgering 20% (182872175.38513092458 NEW)   2 NEW DAO Maintaining DAO 20% (182872175.38513092458 NEW)   3 NewBridge bridge asset 30% (274308263.07769638687 NEW)   4 NewMall Miner NEW staking 30% (274308263.07769638687 NEW)    Implementation #  Part 1 and Part 2 will follow the implementation method of the related themes in NEP-40.\nPart 3 will be granted to NewChain receiving addresses that bridge their assets to NewChain and whose bridge amount is not less than $150.\nPart 4 will be a subsidy for miners targeting newmall.\nCopyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':16,'href':'/neps/nep-53/','title':"Encrypted Variable Token Proposal (NRC-53)",'section':"NEPs",'content':"Simple Summary #  A standard interface for encrypted variable tokens.\nAbstract #  EVT(Encrypted Variable Token) is the replacement of NFT in metaverse and physical world.\nThe key features of EVT are variableness, encryption, traceability.\nThe following standard allows for the implementation of a standard API for EVTs within smart contracts. This standard provides basic functionality to track, transfer, dynamic properties, encryption.\nWe considered the use cases of EVTs including vitality assets, privacy based assets, digital identities. We also considered a diverse universe of assets, and we know you will dream up many more:\n Metaverse — buildings, avatars, flowers, animals Physical property — houses, artwork, movies, tickets “Negative value” assets — loans, burdens and other responsibilities  Motivation #  This document aims to guide the EVT\u0026rsquo;s integration and interoperationality with wallet, marketplace, metaverse.\nSpecification #  EVT will inherit the interfaces of NRC7.\nThe current implementation of EVT is based on solidity programming language. In Solidity, serialization and deserialization is not built-in. So in the implementation of EVT, protobuf3 can be used for the serialization and deserialization of variable properties,\nVariable Interfaces\ninterface EVTVariable { /// @dev This emits when token dynamic property added.  event DynamicPropertyAdded(bytes32 _propertyId); /// @dev This emits when token dynamic property updated.  event DynamicPropertyUpdated(uint256 _tokenId, bytes32 _propertyId, bytes _propertyValue); /// @notice Add the dynamic property  /// @param _propertyId property ID  function addDynamicProperty(bytes32 _propertyId) external payable; /// @notice Set the dynamic property  /// @param _tokenId token ID  /// @param _propertyId property ID  /// @param _propertyValue property value  function setDynamicProperty(uint256 _tokenId, bytes32 _propertyId, bytes _propertyValue) external payable; /// @notice Set multiple dynamic properties once  /// @param _tokenId token ID  /// @param _message message  function setDynamicProperties(uint256 _tokenId, bytes _message) external payable; /// @notice Retrieve the vale of dynamic property  /// @param _tokenId token ID  /// @param _propertyId property ID  /// @return property value  function getDynamicProperty(uint256 _tokenId, bytes32 _propertyId) external view returns (bytes); /// @notice Retrieve the all properties including dynamic and static  /// @param _tokenId token ID  /// @return ids, properties  function getDynamicProperties(uint256 _tokenId) external view returns (bytes32[], bytes[]); /// @notice Check whether support the given property  /// @param _propertyId property ID  /// @return support or unsupport  function supportsProperty(bytes32 _propertyId) external view returns (bool); } _propertyId is calculated by bytes32(keccak256('propertyName')) .\nEncryption Interfaces\ninterface EVTEncryption { ​ /// @notice This emits when registered a encrypted key. ​ /// @param _tokenId token ID ​ /// @param _encryptedKeyId encrypted key ID ​ event EncryptedKeyRegistered(uint256 indexed _tokenId, bytes32 _encryptedKeyId); /// @notice This emits when add a permission. ​ /// @param _tokenId token ID ​ /// @param _encryptedKeyId encrypted key ID ​ /// @param _licensee licensee ​ event PermissionAdded(uint256 indexed _tokenId, bytes32 _encryptedKeyId, address indexed _licensee); /// @notice This emits when remove a permission. ​ /// @param _tokenId token ID ​ /// @param _encryptedKeyId encrypted key ID ​ /// @param _licensee licensee ​ event PermissionRemoved(uint256 indexed _tokenId, bytes32 _encryptedKeyId, address indexed _licensee); /// @notice Register encrypted key  /// @param _tokenId token ID  /// @param _encryptedKeyId encrypted key ID  function registerEncryptedKey(uint256 _tokenId, bytes32 _encryptedKeyId) external payable; /// @notice Add the permission rule of the encrypted key for given address  /// @param _tokenId token ID  /// @param _encryptedKeyId encrypted key ID  /// @param _licensee licensee  function addPermission(uint256 _tokenId, bytes32 _encryptedKeyId, address _licensee) external payable; /// @notice Remove the permission rule of the encrypted key for given address  /// @param _tokenId token ID  /// @param _encryptedKeyId encrypted key ID  /// @param _licensee licensee  function removePermission(uint256 _tokenId, bytes32 _encryptedKeyId, address _licensee) external; /// @notice Check permission rule of the encrypted key for given address  /// @param _tokenId token ID  /// @param _encryptedKeyId encrypted key ID  /// @param _licensee licensee  /// @return true or false  function hasPermission(uint256 _tokenId, bytes32 _encryptedKeyId, address _licensee) external view returns (bool); } The metadata extension is for EVT smart contracts.\ninterface EVTMetadata /* is EVT, NRC7Metadata */ { /// @notice tags for a collection of EVTs in this contract  function from() external view returns (string memory); /// @notice Returns the Uniform Resource Identifier (URI) for the specified EVT tokenId.  /// @dev Throws if `_tokenId` is not a valid EVT. URIs are defined in RFC3986.  /// The URI may point to a JSON file or Base64 encode data that conforms to the  /// \u0026#34;NRC7 Metadata JSON Schema\u0026#34;.  /// @return The JSON formatted URI for the specified EVT tokenId  function tokenURI(uint256 _tokenId) external view returns (string memory); /// @notice Returns the Uniform Resource Identifier (URI) for the storefront-level metadata for your contract.  /// @dev This function SHOULD return the URI for this contract in JSON format, starting with  /// header `data:application/json;base64,`.  /// @return The JSON formatted URI of the current EVT contract  function contractURI() external view returns (string memory); /// @notice Returns the Uniform Resource Identifier (URI) for the variable properties of specified EVT tokenId.  /// @dev This function SHOULD return the URI for those properties in JSON format, starting with  /// header `data:application/json;base64,`.  /// @return The JSON formatted URI for the variable properties of specified EVT tokenId  function variableURI(uint256 _tokenId) external view returns (string memory); /// @notice Returns the Uniform Resource Identifier (URI) for the encryption resources of specified EVT tokenId.  /// @dev This function SHOULD return the URI for those resources in JSON format, starting with  /// header `data:application/json;base64,`.  /// @return The JSON formatted URI for the encryption resources of specified EVT tokenId  function encryptionURI(uint256 _tokenId) external view returns (string memory); } Implementations #  Example implementations are available at\n evt-lib\nReferences #  Standards\n  NEP-7 Non-Fungible Token Standard.  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':17,'href':'/neps/nep-52/','title':"Fee market change for NewChain",'section':"NEPs",'content':"Simple Summary #  This proposal proposes a transaction pricing mechanism, based on Ether EIP-1559, for NewChain that forces to burn a minimum amount per block, while exempting the consensus layer transactions from network fee.\nAbstract #  As described in EIP-1559, we introduce a new EIP-2718 transaction type, with the format 0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]).\nThere is a base fee per gas in protocol, which can move up or down each block according to a formula which is a function of gas used in parent block and gas target (block gas limit divided by elasticity multiplier) of parent block. The algorithm results in the base fee per gas increasing when blocks are above the gas target, and decreasing when blocks are below the gas target. The base fee per gas is burned. Transactions specify the maximum fee per gas they are willing to give to miners to incentivize them to include their transaction (aka: priority fee). Transactions also specify the maximum fee per gas they are willing to pay total (aka: max fee), which covers both the priority fee and the block\u0026rsquo;s network fee per gas (aka: base fee). The transaction will always pay the base fee per gas of the block it was included in, and they will pay the priority fee per gas set in the transaction, as long as the combined amount of the two fees doesn\u0026rsquo;t exceed the transaction\u0026rsquo;s maximum fee per gas.\nNewton makes a unique improvement on this basis by setting a minimum value of BaseFee, that each gas has a minimum burn fee, to avoid the problem of low minimum burn value of each gas due to low network transaction volume. At the same time, the network fee for consensus layer transactions is exempted in order to be compatible with the characteristics of Newton consensus.\nMotivation #  Newton historically priced transaction fees using a simple auction mechanism, where users send transactions with bids (“gasprices”) and miners choose transactions with the highest bids, and transactions that get included pay the bid that they specify. At the same time, Newton node miners functioning normally are able to receive consensus layer rewards NEWNEW so that miners receive both the user\u0026rsquo;s transaction fee and the consensus layer rewards.\nAn important aspect of this fee system is that miners only get to keep the priority fee. The base fee is always burned (i.e. it is destroyed by the protocol).This ensures that only NEW can ever be used to pay for transactions on Newton, cementing the economic value of NEW within the Newton platform. Additionally, this burn counterbalances Newton inflation while still giving the block reward and priority fee to miners. Finally, ensuring the miner of a block does not receive the base fee is important because it removes miner incentive to manipulate the fee in order to extract more fees from users.\nSpecification #  As of FORK_BLOCK_NUMBER, the BaseFee of per block MUST not less than BaseFeeMin where:\n BaseFeeMin is the minimum BaseFee and the value is 250000000000000  Note: // is integer division, round down.\nfrom typing import Union, Dict, Sequence, List, Tuple, Literal from dataclasses import dataclass, field from abc import ABC, abstractmethod @dataclass class TransactionLegacy: signer_nonce: int = 0 gas_price: int = 0 gas_limit: int = 0 destination: int = 0 amount: int = 0 payload: bytes = bytes() v: int = 0 r: int = 0 s: int = 0 @dataclass class Transaction2930Payload: chain_id: int = 0 signer_nonce: int = 0 gas_price: int = 0 gas_limit: int = 0 destination: int = 0 amount: int = 0 payload: bytes = bytes() access_list: List[Tuple[int, List[int]]] = field(default_factory=list) signature_y_parity: bool = False signature_r: int = 0 signature_s: int = 0 @dataclass class Transaction2930Envelope: type: Literal[1] = 1 payload: Transaction2930Payload = Transaction2930Payload() @dataclass class Transaction1559Payload: chain_id: int = 0 signer_nonce: int = 0 max_priority_fee_per_gas: int = 0 max_fee_per_gas: int = 0 gas_limit: int = 0 destination: int = 0 amount: int = 0 payload: bytes = bytes() access_list: List[Tuple[int, List[int]]] = field(default_factory=list) signature_y_parity: bool = False signature_r: int = 0 signature_s: int = 0 @dataclass class Transaction1559Envelope: type: Literal[2] = 2 payload: Transaction1559Payload = Transaction1559Payload() Transaction2718 = Union[Transaction1559Envelope, Transaction2930Envelope] Transaction = Union[TransactionLegacy, Transaction2718] @dataclass class NormalizedTransaction: signer_address: int = 0 signer_nonce: int = 0 max_priority_fee_per_gas: int = 0 max_fee_per_gas: int = 0 gas_limit: int = 0 destination: int = 0 amount: int = 0 payload: bytes = bytes() access_list: List[Tuple[int, List[int]]] = field(default_factory=list) @dataclass class Block: parent_hash: int = 0 uncle_hashes: Sequence[int] = field(default_factory=list) author: int = 0 state_root: int = 0 transaction_root: int = 0 transaction_receipt_root: int = 0 logs_bloom: int = 0 difficulty: int = 0 number: int = 0 gas_limit: int = 0 # note the gas_limit is the gas_target * ELASTICITY_MULTIPLIER gas_used: int = 0 timestamp: int = 0 extra_data: bytes = bytes() proof_of_work: int = 0 nonce: int = 0 base_fee_per_gas: int = 0 @dataclass class Account: address: int = 0 nonce: int = 0 balance: int = 0 storage_root: int = 0 code_hash: int = 0 INITIAL_BASE_FEE = 1000000000 INITIAL_FORK_BLOCK_NUMBER = 10 # TBD BASE_FEE_MAX_CHANGE_DENOMINATOR = 8 ELASTICITY_MULTIPLIER = 2 BASE_FEE_MIN = 250000000000000 # Newton class World(ABC): def validate_block(self, block: Block) -\u0026gt; None: parent_gas_target = self.parent(block).gas_limit // ELASTICITY_MULTIPLIER parent_gas_limit = self.parent(block).gas_limit # on the fork block, don\u0026#39;t account for the ELASTICITY_MULTIPLIER to avoid # unduly halving the gas target. if INITIAL_FORK_BLOCK_NUMBER == block.number: parent_gas_target = self.parent(block).gas_limit parent_gas_limit = self.parent(block).gas_limit * ELASTICITY_MULTIPLIER parent_base_fee_per_gas = self.parent(block).base_fee_per_gas parent_gas_used = self.parent(block).gas_used transactions = self.transactions(block) # check if the block used too much gas assert block.gas_used \u0026lt;= block.gas_limit, \u0026#39;invalid block: too much gas used\u0026#39; # check if the block changed the gas limit too much assert block.gas_limit \u0026lt; parent_gas_limit + parent_gas_limit // 1024, \u0026#39;invalid block: gas limit increased too much\u0026#39; assert block.gas_limit \u0026gt; parent_gas_limit - parent_gas_limit // 1024, \u0026#39;invalid block: gas limit decreased too much\u0026#39; # check if the gas limit is at least the minimum gas limit assert block.gas_limit \u0026gt;= 5000 # check if the base fee is correct if INITIAL_FORK_BLOCK_NUMBER == block.number: expected_base_fee_per_gas = INITIAL_BASE_FEE elif parent_gas_used == parent_gas_target: expected_base_fee_per_gas = parent_base_fee_per_gas elif parent_gas_used \u0026gt; parent_gas_target: gas_used_delta = parent_gas_used - parent_gas_target base_fee_per_gas_delta = max(parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR, 1) expected_base_fee_per_gas = parent_base_fee_per_gas + base_fee_per_gas_delta expected_base_fee_per_gas = max(expected_base_fee_per_gas, BASE_FEE_MIN) # Newton else: gas_used_delta = parent_gas_target - parent_gas_used base_fee_per_gas_delta = parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR expected_base_fee_per_gas = parent_base_fee_per_gas - base_fee_per_gas_delta expected_base_fee_per_gas = max(expected_base_fee_per_gas, BASE_FEE_MIN) # Newton assert expected_base_fee_per_gas == block.base_fee_per_gas, \u0026#39;invalid block: base fee not correct\u0026#39; # execute transactions and do gas accounting cumulative_transaction_gas_used = 0 for unnormalized_transaction in transactions: # Note: this validates transaction signature and chain ID which must happen before we normalize below since normalized transactions don\u0026#39;t include signature or chain ID signer_address = self.validate_and_recover_signer_address(unnormalized_transaction) transaction = self.normalize_transaction(unnormalized_transaction, signer_address) signer = self.account(signer_address) signer.balance -= transaction.amount assert signer.balance \u0026gt;= 0, \u0026#39;invalid transaction: signer does not have enough ETH to cover attached value\u0026#39; # the signer must be able to afford the transaction assert signer.balance \u0026gt;= transaction.gas_limit * transaction.max_fee_per_gas # Newton: consensus layer transactions exemptions if not is_consensus_layer_transaction(transaction): # ensure that the user was willing to at least pay the base fee assert transaction.max_fee_per_gas \u0026gt;= block.base_fee_per_gas # Prevent impossibly large numbers assert transaction.max_fee_per_gas \u0026lt; 2**256 # Prevent impossibly large numbers assert transaction.max_priority_fee_per_gas \u0026lt; 2**256 # The total must be the larger of the two assert transaction.max_fee_per_gas \u0026gt;= transaction.max_priority_fee_per_gas # priority fee is capped because the base fee is filled first priority_fee_per_gas = min(transaction.max_priority_fee_per_gas, transaction.max_fee_per_gas - block.base_fee_per_gas) # signer pays both the priority fee and the base fee effective_gas_price = priority_fee_per_gas + block.base_fee_per_gas # Newton: consensus layer transactions exemptions if is_consensus_layer_transaction(transaction): priority_fee_per_gas = 0 effective_gas_price = 0 signer.balance -= transaction.gas_limit * effective_gas_price assert signer.balance \u0026gt;= 0, \u0026#39;invalid transaction: signer does not have enough ETH to cover gas\u0026#39; gas_used = self.execute_transaction(transaction, effective_gas_price) gas_refund = transaction.gas_limit - gas_used cumulative_transaction_gas_used += gas_used # signer gets refunded for unused gas signer.balance += gas_refund * effective_gas_price # miner only receives the priority fee; note that the base fee is not given to anyone (it is burned) self.account(block.author).balance += gas_used * priority_fee_per_gas # check if the block spent too much gas transactions assert cumulative_transaction_gas_used == block.gas_used, \u0026#39;invalid block: gas_used does not equal total gas used in all transactions\u0026#39; # TODO: verify account balances match block\u0026#39;s account balances (via state root comparison) # TODO: validate the rest of the block def normalize_transaction(self, transaction: Transaction, signer_address: int) -\u0026gt; NormalizedTransaction: # legacy transactions if isinstance(transaction, TransactionLegacy): return NormalizedTransaction( signer_address = signer_address, signer_nonce = transaction.signer_nonce, gas_limit = transaction.gas_limit, max_priority_fee_per_gas = transaction.gas_price, max_fee_per_gas = transaction.gas_price, destination = transaction.destination, amount = transaction.amount, payload = transaction.payload, access_list = [], ) # 2930 transactions elif isinstance(transaction, Transaction2930Envelope): return NormalizedTransaction( signer_address = signer_address, signer_nonce = transaction.payload.signer_nonce, gas_limit = transaction.payload.gas_limit, max_priority_fee_per_gas = transaction.payload.gas_price, max_fee_per_gas = transaction.payload.gas_price, destination = transaction.payload.destination, amount = transaction.payload.amount, payload = transaction.payload.payload, access_list = transaction.payload.access_list, ) # 1559 transactions elif isinstance(transaction, Transaction1559Envelope): return NormalizedTransaction( signer_address = signer_address, signer_nonce = transaction.payload.signer_nonce, gas_limit = transaction.payload.gas_limit, max_priority_fee_per_gas = transaction.payload.max_priority_fee_per_gas, max_fee_per_gas = transaction.payload.max_fee_per_gas, destination = transaction.payload.destination, amount = transaction.payload.amount, payload = transaction.payload.payload, access_list = transaction.payload.access_list, ) else: raise Exception(\u0026#39;invalid transaction: unexpected number of items\u0026#39;) # Newton: consensus layer transactions @abstractmethod def is_consensus_layer_transaction(self, transaction: Transaction) -\u0026gt; bool: pass @abstractmethod def parent(self, block: Block) -\u0026gt; Block: pass @abstractmethod def block_hash(self, block: Block) -\u0026gt; int: pass @abstractmethod def transactions(self, block: Block) -\u0026gt; Sequence[Transaction]: pass # effective_gas_price is the value returned by the GASPRICE (0x3a) opcode @abstractmethod def execute_transaction(self, transaction: NormalizedTransaction, effective_gas_price: int) -\u0026gt; int: pass @abstractmethod def validate_and_recover_signer_address(self, transaction: Transaction) -\u0026gt; int: pass @abstractmethod def account(self, address: int) -\u0026gt; Account: pass Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':18,'href':'/neps/nep-1/','title':"Improvement to Newton Foundation Reserved Token Release Rules",'section':"NEPs",'content':"Summary: #  In order to ensure the scarcity and reasonable liquidity of Newton tokens (NEW), based on the ideas and opinions of all parties, the following suggestions are put forth to modify the token release rules.\nDetails: #  The plan for Newton Foundation reserved token release as stated in the Newton White Paper V0.5 is that “1/2 of the total is immediately unlocked, while the rest will be unlocked 1/12 every month.” Through this NEP, it will be changed to “1/5 of the total is immediately released, while the rest will be unlocked 1/36 every month,” and published in the Newton White Paper V0.6.\nRelated materials: #   Newton White Paper: https://www.newtonproject.org/whitepaper/ Newton website: https://www.newtonproject.org/  "});index.add({'id':19,'href':'/neps/nep-10/','title':"Invoice Token Standard (NRC-10)",'section':"NEPs",'content':"Simple Summary #  A standard interface for invoice token.\nAbstract #  The following standard allows for the implementation of a standard API for invoice token within smart contracts. This standard provides basic functionality to issue、reimburse and invalidate invoice token.\nMotivation #  A standard interface allows tax/invoice/financial applications to work with invoice token on NewChain. We provide for simple invoiceToken smart contracts as well as contracts that track an arbitrarily large number of invoice tokens.\nThe invoice token will curb malpractice and document forgery in taxation and simplify procedures.\nSpecification #  Meta Data #     Item Description Behaviors/Properties     Owner can take full control of contract deploy contract, add/remove addmin, set fee   Admin manage enterprise authorize/revoke enterprise   Enterprise manage token(Invoice) issue/reimburse/invalidate token   Fee issue token(invoice) fee uint ISSAC   FeeAddress fee withdrawal to this address    Invoice contains operatorAddress, sellerTaxNumber, buyerTaxNumber, operatorName, invoiceInfo, status, financial status: positive、negative(reversal)、blank cancellation、cancellation, financial: received、recorded    Interaction / Functions #     Function Description Behaviors/Properties     owner     addAdmin add admin to this contract permission: owner   removeAdmin remove admin from this contract permission: owner   setFee set issue fee，uint ISSAC permission: owner   setFeeAddress set issue fee withdrawal address permission: owner   withdraw withdrawal to feeAddress permission: owner   admin     authorize authorized _enterpriseAddress to join contract permission: admin   revoke revoke _enterpriseAddress from this contract permission: admin   enterprise     issue issue new token(Invoice) by msg.sender permission: enterprise   issueFrom issue new token(Invoice) by the approved address of the seller permission: enterprise   reimburse change Invoice financial status from received to recorded permission: enterprise   invalidate change Invoice status from positive to _newStatus permission: enterprise   setApprovalForAll enable or disable approval for a third party (\u0026ldquo;operator\u0026rdquo;) to manage all of msg.sender\u0026rsquo;s invoice token permission: enterprise   Query     totalSupply return issue invoices fee total    balanceOfSeller return sell invoices count    balanceOfBuyer return buy invoices count    tokenById return Invoice info    getFee return issue invoice fee    getFeeSum return contract revenue    getFeeBalance return contract balance    isApprovedForAll check is authorizationed    isExist check token is existed     Test Cases #  The reference implementation contains all the tests.\nImplementation #  pragma solidity ^0.5.0; interface INRC10{ ///////////////////////////////////////////////////  // function for owner //  ///////////////////////////////////////////////////  event AdminAdded(address _admin); function addAdmin (address _admin) external public onlyOwner; event AdminRemoved(address _admin); function removeAdmin (address _admin) external public onlyOwner; event SetFeeSeted(uint _fee); //set issue fee，uint ISSAC  function setFee(uint _fee) external public onlyOwner; event FeeAddressSeted(address _feeAddress); //set issue fee withdrawal address  function setFeeAddress(address payable _feeAddress) external public onlyOwner; event FeeAndFeeAddressSeted(uint _fee, address _feeAddress); function setFeeAndFeeAddress(uint _fee, address payable _feeAddress) external public onlyOwner; event WithdrawalSuccess(address indexed _to, uint _amount); //uint ISSAC  function withdraw(uint _withraw_amount) external public onlyOwner; ///////////////////////////////////////////////////  // function for admin //  ///////////////////////////////////////////////////  event AuthorizeSuccess(address _admin, address _enterpriseAddress, string _taxNumber); //authorized enterprise to join contract  function authorize (address _enterpriseAddress, string memory _taxNumber) external public; event RevokeSuccess(address _admin, address _enterpriseAddress); //revoke enterprise  function revoke (address _enterpriseAddress) external public; ///////////////////////////////////////////////////  // function for enterprise //  ///////////////////////////////////////////////////  event Issued(address _send, string _from, string _to, bytes32 _tokenId); //issue Invoice  function issue(string memory _to, bytes32 _tokenId, string memory _operatorName, string memory _invoiceInfo) external payable public; function issueFrom(string memory _from, string memory _to, bytes32 _tokenId, string memory _operatorName, string memory _invoiceInfo) external payable public; event ReimburseSuccess(address _enterprise, bytes32 _tokenId); function reimburse(bytes32 _tokenId) external public; event InvalidateSuccess(address _enterprise, bytes32 _tokenId, uint8 _newStatus); function invalidate(bytes32 _tokenId, uint8 _newStatus) external public; event ApprovalForAllSeted(address _from, address _operator, bool _approved); function setApprovalForAll(address _operator, bool _approved) external public; ///////////////////////////////////////////////////  // function for all //  ///////////////////////////////////////////////////  //return issue invoices total  function totalSupply() external public view returns (uint); //return sell invoices count  function balanceOfSeller(string memory _taxNumber) external public view returns (uint); // return buy invoices count  function balanceOfBuyer(string memory _taxNumber) external public view returns (uint); //return issue invoice fee, uint ISSAC  function getFee() external public view returns (uint); //return contract revenue，uint ISSAC  function getFeeSum() external public view returns (uint); //return contract balance，uint ISSAC  function getFeeBalance() external public view returns (uint); //return is authorizationed  function isApprovedForAll(address _owner, address _operator) external public view returns (bool); //return invoce info  function tokenById(bytes32 _tokenId) external public view returns; function isExist(bytes32 _tokenId) external public view returns (bool); } The reference implementation\nReferences #   ERC-721 Token Standard. https://eips.ethereum.org/EIPS/eip-721  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':20,'href':'/neps/nep-50/','title':"Multi Token Standard (NRC-50)",'section':"NEPs",'content':"Simple Summary #  A standard interface for contracts that manage multiple token types. A single deployed contract may include any combination of fungible tokens, non-fungible tokens or other configurations (e.g. semi-fungible tokens).\nAbstract #  This standard outlines a smart contract interface that can represent any number of fungible and non-fungible token types. Existing standards such as NRC-6 require deployment of separate contracts per token type. The NRC-7 standard’s token ID is a single non-fungible index and the group of these non-fungibles is deployed as a single contract with settings for the entire collection. In contrast, the NRC-50 Multi Token Standard allows for each token ID to represent a new configurable token type, which may have its own metadata, supply and other attributes.\nThe _id argument contained in each function’s argument set indicates a specific token or token type in a transaction.\nMotivation #  Tokens standards like NRC-6 and NRC-7 require a separate contract to be deployed for each token type or collection. This places a lot of redundant bytecode on the Ethereum blockchain and limits certain functionality by the nature of separating each token contract into its own permissioned address. With the rise of blockchain games and platforms like Enjin Coin, game developers may be creating thousands of token types, and a new type of token standard is needed to support them. However, NRC-50 is not specific to games and many other applications can benefit from this flexibility.\nNew functionality is possible with this design such as transferring multiple token types at once, saving on transaction costs. Trading (escrow / atomic swaps) of multiple tokens can be built on top of this standard and it removes the need to “approve” individual token contracts separately. It is also easy to describe and mix multiple fungible or non-fungible token types in a single contract.\nSpecification #  The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.\nSmart contracts implementing the NRC-50 standard MUST implement all of the functions in the NRC50 interface.\nSmart contracts implementing the NRC-50 standard MUST implement the ERC-165 supportsInterface function and MUST return the constant value true if 0xd9b67a26 is passed through the interfaceID argument.\npragma solidity ^0.5.9; /** @title NRC-50 Multi Token Standard Note: The ERC-165 identifier for this interface is 0xd9b67a26. */ interface NRC50 /* is ERC165 */ { /** @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \u0026#34;Safe Transfer Rules\u0026#34; section of the standard). The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender). The `_from` argument MUST be the address of the holder whose balance is decreased. The `_to` argument MUST be the address of the recipient whose balance is increased. The `_id` argument MUST be the token type being transferred. The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by. When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address). When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address). */ event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value); /** @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \u0026#34;Safe Transfer Rules\u0026#34; section of the standard). The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender). The `_from` argument MUST be the address of the holder whose balance is decreased. The `_to` argument MUST be the address of the recipient whose balance is increased. The `_ids` argument MUST be the list of tokens being transferred. The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by. When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address). When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address). */ event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values); /** @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled). */ event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); /** @dev MUST emit when the URI is updated for a token ID. URIs are defined in RFC 3986. The URI MUST point to a JSON file that conforms to the \u0026#34;ERC-1155 Metadata URI JSON Schema\u0026#34;. */ event URI(string _value, uint256 indexed _id); /** @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call). @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \u0026#34;Approval\u0026#34; section of the standard). MUST revert if `_to` is the zero address. MUST revert if balance of holder for token `_id` is lower than the `_value` sent. MUST revert on any other error. MUST emit the `TransferSingle` event to reflect the balance change (see \u0026#34;Safe Transfer Rules\u0026#34; section of the standard). After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size \u0026gt; 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \u0026#34;Safe Transfer Rules\u0026#34; section of the standard). @param _from Source address @param _to Target address @param _id ID of the token type @param _value Transfer amount @param _data Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to` */ function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external; /** @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call). @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \u0026#34;Approval\u0026#34; section of the standard). MUST revert if `_to` is the zero address. MUST revert if length of `_ids` is not the same as length of `_values`. MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient. MUST revert on any other error. MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \u0026#34;Safe Transfer Rules\u0026#34; section of the standard). Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc). After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size \u0026gt; 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \u0026#34;Safe Transfer Rules\u0026#34; section of the standard). @param _from Source address @param _to Target address @param _ids IDs of each token type (order and length must match _values array) @param _values Transfer amounts per token type (order and length must match _ids array) @param _data Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to` */ function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external; /** @notice Get the balance of an account\u0026#39;s tokens. @param _owner The address of the token holder @param _id ID of the token @return The _owner\u0026#39;s balance of the token type requested */ function balanceOf(address _owner, uint256 _id) external view returns (uint256); /** @notice Get the balance of multiple account/token pairs @param _owners The addresses of the token holders @param _ids ID of the tokens @return The _owner\u0026#39;s balance of the token types requested (i.e. balance for each (owner, id) pair) */ function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory); /** @notice Enable or disable approval for a third party (\u0026#34;operator\u0026#34;) to manage all of the caller\u0026#39;s tokens. @dev MUST emit the ApprovalForAll event on success. @param _operator Address to add to the set of authorized operators @param _approved True if the operator is approved, false to revoke approval */ function setApprovalForAll(address _operator, bool _approved) external; /** @notice Queries the approval status of an operator for a given owner. @param _owner The owner of the tokens @param _operator Address of authorized operator @return True if the operator is approved, false if not */ function isApprovedForAll(address _owner, address _operator) external view returns (bool); } NRC-50 Token Receiver #  Smart contracts MUST implement all of the functions in the NRC50TokenReceiver interface to accept transfers. See “Safe Transfer Rules” for further detail.\nSmart contracts MUST implement the ERC-165 supportsInterface function and signify support for the NRC50TokenReceiver interface to accept transfers. See “NRC50TokenReceiver ERC-165 rules” for further detail.\npragma solidity ^0.5.9; /** Note: The ERC-165 identifier for this interface is 0x4e2312e0. */ interface NRC50TokenReceiver { /** @notice Handle the receipt of a single NRC50 token type. @dev An NRC50-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated. This function MUST return `bytes4(keccak256(\u0026#34;onERC1155Received(address,address,uint256,uint256,bytes)\u0026#34;))` (i.e. 0xf23a6e61) if it accepts the transfer. This function MUST revert if it rejects the transfer. Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller. @param _operator The address which initiated the transfer (i.e. msg.sender) @param _from The address which previously owned the token @param _id The ID of the token being transferred @param _value The amount of tokens being transferred @param _data Additional data with no specified format @return `bytes4(keccak256(\u0026#34;onERC1155Received(address,address,uint256,uint256,bytes)\u0026#34;))` */ function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4); /** @notice Handle the receipt of multiple NRC50 token types. @dev An NRC50-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated. This function MUST return `bytes4(keccak256(\u0026#34;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\u0026#34;))` (i.e. 0xbc197c81) if it accepts the transfer(s). This function MUST revert if it rejects the transfer(s). Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller. @param _operator The address which initiated the batch transfer (i.e. msg.sender) @param _from The address which previously owned the token @param _ids An array containing ids of each token being transferred (order and length must match _values array) @param _values An array containing amounts of each token being transferred (order and length must match _ids array) @param _data Additional data with no specified format @return `bytes4(keccak256(\u0026#34;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\u0026#34;))` */ function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4); } Safe Transfer Rules #  To be more explicit about how the standard safeTransferFrom and safeBatchTransferFrom functions MUST operate with respect to the NRC50TokenReceiver hook functions, a list of scenarios and rules follows.\nMetadata #  The URI value allows for ID substitution by clients. If the string {id} exists in any URI, clients MUST replace this with the actual token ID in hexadecimal form. This allows for a large number of tokens to use the same on-chain string by defining a URI once, for that large number of tokens.\n The string format of the substituted hexadecimal ID MUST be lowercase alphanumeric: [0-9a-f] with no 0x prefix. The string format of the substituted hexadecimal ID MUST be leading zero padded to 64 hex characters length if necessary.  Example of such a URI: https://token-cdn-domain/{id}.json would be replaced with https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json if the client is referring to token ID 314592/0x4CCE0.\nMetadata Extensions The optional NRC50Metadata_URI extension can be identified with the ERC-165 Standard Interface Detection.\nIf the optional NRC50Metadata_URI extension is included:\n The ERC-165 supportsInterface function MUST return the constant value true if 0x0e89341c is passed through the interfaceID argument. Changes to the URI MUST emit the URI event if the change can be expressed with an event (i.e. it isn’t dynamic/programmatic). An implementation MAY emit the URI event during a mint operation but it is NOT mandatory. An observer MAY fetch the metadata uri at mint time from the uri function if it was not emitted. The uri function SHOULD be used to retrieve values if no event was emitted. The uri function MUST return the same value as the latest event for an _id if it was emitted. The uri function MUST NOT be used to check for the existence of a token as it is possible for an implementation to return a valid string even if the token does not exist.  pragma solidity ^0.5.9; /** Note: The ERC-165 identifier for this interface is 0x0e89341c. */ interface NRC50Metadata_URI { /** @notice A distinct Uniform Resource Identifier (URI) for a given token. @dev URIs are defined in RFC 3986. The URI MUST point to a JSON file that conforms to the \u0026#34;ERC-1155 Metadata URI JSON Schema\u0026#34;. @return URI string */ function uri(uint256 _id) external view returns (string memory); } NRC-50 Metadata URI JSON Schema This JSON schema is loosely based on the “NRC7 Metadata JSON Schema”, but includes optional formatting to allow for ID substitution by clients. If the string {id} exists in any JSON value, it MUST be replaced with the actual token ID, by all client software that follows this standard.\n The string format of the substituted hexadecimal ID MUST be lowercase alphanumeric: [0-9a-f] with no 0x prefix. The string format of the substituted hexadecimal ID MUST be leading zero padded to 64 hex characters length if necessary.  { \u0026quot;title\u0026quot;: \u0026quot;Token Metadata\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Identifies the asset to which this token represents\u0026quot; }, \u0026quot;decimals\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;The number of decimal places that the token amount should display - e.g. 18, means to divide the token amount by 1000000000000000000 to get its user representation.\u0026quot; }, \u0026quot;description\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Describes the asset to which this token represents\u0026quot; }, \u0026quot;image\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.\u0026quot; }, \u0026quot;properties\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Arbitrary properties. Values may be strings, numbers, object or arrays.\u0026quot; } } } An example of an NRC-50 Metadata JSON file follows. The properties array proposes some SUGGESTED formatting for token-specific display properties and metadata.\n{ \u0026quot;name\u0026quot;: \u0026quot;Asset Name\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Lorem ipsum...\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;https:\\/\\/s3.amazonaws.com\\/your-bucket\\/images\\/{id}.png\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;simple_property\u0026quot;: \u0026quot;example value\u0026quot;, \u0026quot;rich_property\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;Name\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;display_value\u0026quot;: \u0026quot;123 Example Value\u0026quot;, \u0026quot;class\u0026quot;: \u0026quot;emphasis\u0026quot;, \u0026quot;css\u0026quot;: { \u0026quot;color\u0026quot;: \u0026quot;#ffffff\u0026quot;, \u0026quot;font-weight\u0026quot;: \u0026quot;bold\u0026quot;, \u0026quot;text-decoration\u0026quot;: \u0026quot;underline\u0026quot; } }, \u0026quot;array_property\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;Name\u0026quot;, \u0026quot;value\u0026quot;: [1,2,3,4], \u0026quot;class\u0026quot;: \u0026quot;emphasis\u0026quot; } } } Localization Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content MAY be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.\nJSON Schema\n{ \u0026quot;title\u0026quot;: \u0026quot;Token Metadata\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Identifies the asset to which this token represents\u0026quot;, }, \u0026quot;decimals\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;The number of decimal places that the token amount should display - e.g. 18, means to divide the token amount by 1000000000000000000 to get its user representation.\u0026quot; }, \u0026quot;description\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Describes the asset to which this token represents\u0026quot; }, \u0026quot;image\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.\u0026quot; }, \u0026quot;properties\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Arbitrary properties. Values may be strings, numbers, object or arrays.\u0026quot;, }, \u0026quot;localization\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;required\u0026quot;: [\u0026quot;uri\u0026quot;, \u0026quot;default\u0026quot;, \u0026quot;locales\u0026quot;], \u0026quot;properties\u0026quot;: { \u0026quot;uri\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;The URI pattern to fetch localized data from. This URI should contain the substring `{locale}` which will be replaced with the appropriate locale value before sending the request.\u0026quot; }, \u0026quot;default\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;The locale of the default data within the base JSON\u0026quot; }, \u0026quot;locales\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;array\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;The list of locales for which data is available. These locales should conform to those defined in the Unicode Common Locale Data Repository (http://cldr.unicode.org/).\u0026quot; } } } } } Base URI:\n{ \u0026quot;name\u0026quot;: \u0026quot;Advertising Space\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Each token represents a unique Ad space in the city.\u0026quot;, \u0026quot;localization\u0026quot;: { \u0026quot;uri\u0026quot;: \u0026quot;ipfs://QmWS1VAdMD353A6SDk9wNyvkT14kyCiZrNDYAad4w1tKqT/{locale}.json\u0026quot;, \u0026quot;default\u0026quot;: \u0026quot;en\u0026quot;, \u0026quot;locales\u0026quot;: [\u0026quot;en\u0026quot;, \u0026quot;es\u0026quot;, \u0026quot;fr\u0026quot;] } } es.json:\n{ \u0026quot;name\u0026quot;: \u0026quot;Espacio Publicitario\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Cada token representa un espacio publicitario único en la ciudad.\u0026quot; } fr.json:\n{ \u0026quot;name\u0026quot;: \u0026quot;Espace Publicitaire\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Chaque jeton représente un espace publicitaire unique dans la ville.\u0026quot; } Rationale #  Metadata Choices #  The symbol function (found in the NRC-6 and NRC-7 standards) was not included as we do not believe this is a globally useful piece of data to identify a generic virtual item / asset and are also prone to collisions. Short-hand symbols are used in tickers and currency trading, but they aren’t as useful outside of that space.\nThe name function (for human-readable asset names, on-chain) was removed from the standard to allow the Metadata JSON to be the definitive asset name and reduce duplication of data. This also allows localization for names, which would otherwise be prohibitively expensive if each language string was stored on-chain, not to mention bloating the standard interface. While this decision may add a small burden on implementers to host a JSON file containing metadata, we believe any serious implementation of NRC-50 will already utilize JSON Metadata.\nUpgrades #  The requirement to emit TransferSingle or TransferBatch on balance change implies that a valid implementation of NRC-50 redeploying to a new contract address MUST emit events from the new contract address to replicate the deprecated contract final state. It is valid to only emit a minimal number of events to reflect only the final balance and omit all the transactions that led to that state. The event emit requirement is to ensure that the current state of the contract can always be traced only through events. To alleviate the need to emit events when changing contract address, consider using the proxy pattern, such as described in EIP-2535. This will also have the added benefit of providing a stable contract address for users.\nDesign decision: Supporting non-batch #  The standard supports safeTransferFrom and onERC1155Received functions because they are significantly cheaper for single token-type transfers, which is arguably a common use case.\nDesign decision: Safe transfers only #  The standard only supports safe-style transfers, making it possible for receiver contracts to depend on onERC1155Received or onERC1155BatchReceived function to be always called at the end of a transfer.\nGuaranteed log trace #  As the Ethereum ecosystem continues to grow, many dapps are relying on traditional databases and explorer API services to retrieve and categorize data. The NRC-50 standard guarantees that event logs emitted by the smart contract will provide enough data to create an accurate record of all current token balances. A database or explorer may listen to events and be able to provide indexed and categorized searches of every NRC-50 token in the contract.\nApproval #  The function setApprovalForAll allows an operator to manage one’s entire set of tokens on behalf of the approver. It enables frictionless interaction with exchange and trade contracts.\nRestricting approval to a certain set of token IDs, quantities or other rules MAY be done with an additional interface or an external contract. The rationale is to keep the NRC-50 standard as generic as possible for all use-cases without imposing a specific approval scheme on implementations that may not need it. Standard token approval interfaces can be used, such as the suggested ERC-1761 Scoped Approval Interface which is compatible with NRC-50.\nTest Cases #  TBD\nImplementations #  TBD\nReferences #   ERC-1155 Multi Token Standard. https://eips.ethereum.org/EIPS/eip-1155 ERC-721 Non-fungible Token Standard. https://eips.ethereum.org/EIPS/eip-721 ERC-165 Standard Interface Detection. https://eips.ethereum.org/EIPS/eip-165 NRC6 Token Standard. https://github.com/newtonproject/NEPs/blob/main/NEPS/nep-6/index.md  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':21,'href':'/neps/nep-23/','title':"NEAT Backed Currency (NBC)",'section':"NEPs",'content':"Simple Summary #   NEAT Backed Currency (NBC) is a kind of cryptographically secured currency following the design protocol of NEAT. The goal of this creation is the allow anyone to create a set of exchangeable, and divisible asset that can be securely exchanged using the platform provided by Newton Community. We used the term community, because the distributed security, must be backed by a community of infrastructure providers and a rather healthy exchange community. By sharing the same set of features and capabilities developed by the entire Newton Community (NC), the quality and functionalities of the \u0026ldquo;currency\u0026rdquo; of interest could leverage the engineering and community support that has been developed over the years.\n Abstract #  NEAT-based Currency (NBC), is a divisible kind of asset that can be used as a unit of exchangeable value, to be transferred between two accounts in a community of choice. This community must leverage certain set of cryptographically secure protocols, so that asset exchange can be conducted under the same level of cryptographic protection. To create a new currency for exchange in a chosen community, certain community identity management system, and its account management system must be in place. For now, we will assume that the participants will start with existing Newton ID and NewKYC account management system. So that they will enjoy the same level of security. More over, all NEAT-backed Currency should follow the requirement as mentioned below:\n A currency must be guaranteed by a collateral asset, controllable under a cryptographically protected system, The entire transaction history will leverage NewChain\u0026rsquo;s secure timestamping services, The initial participating accounts will only include NewID and NewKYC, The exchangeable asset (currency) identities must be conserved and immutable (Quantitative Easing NOT ALLOWED), The participation of asset exchange can be defined by the NBC issuers and participants. Univalence: the security and value of cryptographically protected asset is defined by a unifying technical parameters of the security system. When there is a large number of NBCs, individual NBC\u0026rsquo;s technical security risk can be isolated from the market value fluctuation of a specific currency.  Motivation #  There are many organizational or community governance tasks that requires certain scoring or asset distribution system. To construct a secure system takes both technical know how and a significant amount of financial investment. NBC provides a solution to allow a larger number of people to create a small pool of assets, and allow these assets to be exchanged between participating parties. To make this system generally useful, the goal of NBC is to isolate the value of exchangeable asset from external marketplace as much as possible. Participants should measure and assess the value of the currency, purely on the security features of the exchange system, and a common clock of all exchange activities. This isolation of value judgement will significantly broaden the use of NBC, and allows more people to adopt this infrastructure of their own use. We list a number of possible usecase scenarios to motivate the design.\nSoftware Implementation and Content Development Communities #  A key component of value in cooperative content development or software development, is not often not the financial incentives, but the timing of content presentation. If an open source community has a high rate of bug-fixing responses, the overall user satisfaction will increase, therefore improve the ecology of the software user community as a whole. Therefore, the key incentive structure is to have a indifferent time keeper, that registers and rewards contributors of content, that most quickly resolves the issue. In other words, the currency in the community is response time. Clearly, the market value of the response time should be validated by the actual trajectory of content/software adoption curve. Therefore, the issuance of currency can be grounded on that type of data. In other words, having a system that distribute rewards based on commonly observed data, not just temporary market arbitrage activities for some external assets, such as USDT or other highly liquid asset, will protect the essential value of a localized currency.\nCommunity Services #  To mobilize community services, it is often necessary to keep a regular tab on how many times or how often certain services is delivered. For those contributors who are most regularly, or most frequently serving the community, a system like NBC could be the ledger of the fragmented community activities. For example, garbage pick-up and food deliver could be measured based on their record of being on-time. NBC could serve this area in helping teams to manage the quality of service using a combination of secure time stamps and other verifiable data.\nPhysical Security and Social Gathering/Distancing Measures #  A critical feature of Newchain is its 3 second resolution in data blocks. This highly responsive data update rates, provide a reasonable mechanism to help monitor the physical states of certain assets and define values based on the data records. For example, high density presence of mobile phones in a certain location, could indicate the physical location has high commercial/advertisement values, or large social distance risks. Therefore, issuing a currency based on this rather objective and publicly observable data set, can offer a meaningful metric to define the value of physical presence in certain time slots. This kind of applications can be better supported by NBC, when assets or score keeping systems are bound to the high-resolution Newchain timestamps.\nOther Applications in generalized digital workflow #  Any social or economic applications that deal with value changing with time could use NBC to measure the value created or dissipated over time. By focusing on the causal possibilities of offering solutions across the reachable locations within Newton Community, any account could contribute to or benefit from the publication of the availability of physical services or digital content. The timing and causal relations between any events, could be written up as motivating programs that identify certain patterns of behavior and direct resources for that behavior. This general programming paradigm is often called policy design. NBC provides a general purpose platform to develop executable policies under one infrastructure.\nSpecification #  Initially NBC just need to define the name of the currency, the total amount of its exchangeable units, and the conditions of who and when certain participants can exchange the declared units. For the purpose of human cognitive load, NBC will not allow quantitative easing, or splitting or stock, in any NBC. To make certain asset having more divisible resolution, one can transfer all the asset into a new NBC. That means, this division will require a significant amount of participant to agree with such transfer. In any case, NBC should be simple, so that people know what they are getting into and what they will face into the future. Once certain asset transfer policy is issued for an NBC, all existing asset will follow the same policy from that point onward. So that all asset valuation will attain certain consistency in value exchange.\nSyntax and Semantics #  The issuance of NBC can follow the following procedure:\n   Step Essential Term Explanation     1 Initial State Identify an unused name in the NBC registry   2 Guaranteed Deposit Certain initiator deposits certain valuable asset for the initial offering of NBC.   3 Exit Policy A self-executing \u0026ldquo;smart contract\u0026rdquo; will be written for how to redistribute the division of deposited asset when the NBC must be dissolved.   4 Immutable Division Define a total number of divisions for the newly created NBC. This cannot be changed ever   5 Distribution Rights The account that deposited the initial asset will have the right to distribute the divisions as created.   6 Participation Rights A \u0026ldquo;smart contract\u0026rdquo;, or a list of conditions for who in the Newton Community can participate in the exchange.   7 Rights to Expand Properties Any participant can increase the deposit   8 Backward Compatibility Any NBC account has the right to continue cash out residual value based on current exchange rates or the Exit Policy    Deployment Procedures #  The creation of NBC should follow a conservative stance. The goal is not to quickly create many exchangeable assets, so that many people could quickly create many gambling pools. The goal is to create a series of highly secure and useful patterns for governance. Therefore, the following policies should be obeyed to reduce, and ideally eliminate opportunistic creation of NBC.\n  All newly created NBC should have an initially high entrance barrier, such as a large deposit, and it should be locked down in months even years, so that it forces creators of new NBC would not be short term players.\n  All NBCs are some form of community or organizational governance instrument, so that its use and its performance data in real time is of great value. It should be protected and would follow the same kind of public disclosure and participants' identities would be protected using a set of security measures offered by the Newton Infrastructure.\n  Because all NBCs must be kept for as long as Newton Infrastructure exists. Therefore, a maintenance fee for its data and bandwidth consumption must be collected to support the infrastructure. This amount of fee needs to be dynamically adjusted based on the ongoing pricing of computation and communication costs at the time.\n  Rationale (optional) #  Allowing non-technical people to create NBC is the mission. However, there are much more governance techniques required to manage and orchestrate the communities that uses NBC. Currency issuance is clearly going to be a new dimension that organizations that adopts NBC must learn from the overall Newton Community. Therefore, a think tank organization that specializes in currency mechanism design must be initiated to develop material that shows NBC creators and participants to better practice their use of NBC. Currency is designed to be liquidable assets, so that it is a double edged swords. It must be used with tremendous care.\nTest Cases (optional) #  Newton Community itself should be the first one to practice the use of NBC. The currency should be the Newton currency as it is being used on the Internet.\nBefore we deploy the first NBC, certain kind of social dynamics and organizational infrastructure must be prepared. For example, one should use TLA+ and NetLogo to assess the symbolic dynamics and agent-based system dynamics of a group of participating agents. Then, a procedure will be deployed and submitted to the following Safety and Liveness tests. After certain iteration, we will deploy the actual NBC to Newton Community.\n Safety tests: After a meaningful NBC creation procedure is defined, a relatively small amount of Newton should be issued as a test case for NBC creation. Then, the community that develops NEPs and other mechanisms for Newton Community evolution should be organized through this NBC. Liveness tests: The cases where the first NBC is being used and how it affects the community could be the liveness case study.  Implementation #  Ideally, all Newton Community\u0026rsquo;s incentive and organizational structures should be managed through the governance procedures of NBC.\nSecurity Considerations #  To ensure security, creation of NBC must go through certain stress test and system test phases. The proposition here is that the first three years, all NBC creation should be submitted through both technical and branding committee, so that decisions for creating currencies would not contradict, or competing with each other for obvious reasons. Overtime, the competing interests should be encoded into some kind of Byzantine Fault Tolerance Mechanism.\nReferences #   Leslie Lamport, Time, Clocks, and the Ordering of Events in a Distributed System, Communications of the ACM, July, 1978.  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':22,'href':'/neps/nep-0/','title':"NEP Genesis",'section':"NEPs",'content':"Summary: #  For the sake of the open, transparent governance, we propose compiling all suggestions related to the Newton Project using the Newton Evolution Proposal (NEP) template for unified numbering and management. The proposals are then put to the community for broader discussion, getting opinions and suggestions from all parties involved before forming final conclusions.\nDetails: #   Anyone can submit an NEP. The Newton Foundation is responsible for assigning an exclusive number to each. All subsequent NEPs must use this format as a template. The status may be “draft in discussion,” “not accepted,” “awaiting implementation,” “implemented,” or “implementation delayed.” The category may be “economic model,” “personnel,” “technical,” “community governance,” or “business.” After submission of the NEP, it is sent to the community for broader discussion, getting opinions and suggestions from all parties before a final decision is made. The “draft in discussion” stage lasts 30 calendar days. If no decision is reached during that stage, the status is changed to “not accepted.”  "});index.add({'id':23,'href':'/guides/','title':"NEPs Guidelines",'section':"Home",'content':"This is General Guidelines Section for Newton Evolution Proposals. We welcome anyone with suggestions related to Newton Project to compile a NEP.\nParties Involved In A NEP #  Parties \u0026amp; Roles involved in the process a NEP are:\n NEP Champion(Lead) \u0026amp; Authors  NEP Editors  NEP Review Board and the Public Communnity  How To Start A NEP #  We welcome anyone with suggestions related to Newton Project to compile a NEP.\nBefore you begin writing a formal NEP, you should vet your idea. Ask the Newton community first if an idea is original to avoid wasting time on something that will be be rejected based on prior research.\nContinue on:\n  Contributing A NEP  NEP Submission Guides for Beginners  NEP Format and Templates  NEP Process Workflow #  General NEP Process\nFollowing is the process that a successful NEP will move along with it\u0026rsquo;s status change:\n[ WIP ] -\u0026gt; [ DRAFT ] -\u0026gt; [ PUBLIC CALL ] -\u0026gt; [ FINAL / ACTIVE ] More details covered in:\n  NEP Status Document.  NEP Process Document.  Documentatons List #   Contributing a NEP Guide for start a NEP and making updates\n   NEP Submission Guides for Beginners Detailed guide for unfamiliar with the NEP Process\n   NEP Process How NEP is proccessed and status is changed during the process\n   NEP Format and Templates NEP Format and Templates\n   NEP Status Standard NEP Status for Newton Evolution Proposals.\n   NEP Editors NEP Editors are maintainers to NEPs.\n   Review Board Review Board Members review and vote for NEPs\n   Transferring NEP Ownership It occasionally becomes necessary to transfer ownership of NEPs to a new champion.\n   About This Guideline #  This document was derived heavily from Ethereum\u0026rsquo;s EIP-1 which was derived Bitcoin\u0026rsquo;s BIP-0001 written by Amir Taaki which in turn was derived from Python\u0026rsquo;s PEP-0001 In many places text was simply copied and modified. The authors in the documents mentioned above are not responsible for its use in the Newton Evolution Proposal, and should not be bothered with questions specific to Newton or the NEP. Please direct all comments to the NEP editors.\n 2020-04-24: This NEP Guideline was created and released with e6a58cb 2021-01-11: This NEP Guideline was updated with bf4dc74 and will accept furthur edits on NEPs repo from now on.  "});index.add({'id':24,'href':'/neps/nep-45/','title':"NewChain Ledger Node Incentive Program",'section':"NEPs",'content':"Simple Summary #  This NEP defines how NewChain Ledger Node Incentive is used from Newton Incentive Program in NEP-40.\nMotivation #   NEP-40 proposed Newton Incentive Program and a 20% of NEW from that program will be used to NewChain Ledger Nodes. A specification of implementation is required for that, which comes to this NewChain Ledger Node Incentive Program.\nSpecification #  Prerequisites for Ledger Node #    Having an active Community Node.\n  At least 10,000,000 NEW of total staking in the Community Node.\n   For the partnership node, the total staking is added by the staking of the owner and the staking of the partners. For the non-partnership node, the total staking is staked by the owner.  Run a NewChain Node and apply to become the Ledger Node on NewChain Mainnet, details described in NEP-27.  Incentive Distribution #  The Incentive to Ledger Nodes is distributed each day until the Incentive Program end.\nOnly the owner of the Ledger Node will receive the incentive since it is the owner who manages the Ledger Node.\nIncentive Period #  Incentive_Period: total days since Incentive Program implemented on NewChain Mainnet until 2022/1/31 (included).\nTotal Incentive Amount #  Total_Incentive: 175026053.57892763572 NEW, which defined in NEP-40.\nTotal Daily Incentive Amount #  Total_Daily_Incentive = Total_Incentive / Incentive_Period\nOwner Staking Amount #  Owner_Staking: The amount of NEW staked by the owner of the Ledger Node.\nTotal Staking Amount #  Total_Staking: Total amount of NEW staked by the owners of All Ledger Node.\nStaking Snapshot #  The staking amount for each Ledger Node is based on the snapshot of the first block created after UTC-0 each day.\nNode Daily Incentive #  For each qualified Ledger Node, the amount of NEW from NewChain Ledger Node Incentive Program on each day:\nNode_Daily_Incentive = Total_Daily_Incentive * Owner_Staking / Total_Staking\nCopyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':25,'href':'/neps/nep-27/','title':"NewChain MainNet Opening",'section':"NEPs",'content':"Simple Summary #  After NewChain TestNet successful opening, NewChain MainNet is going to be opened by inviting the community to setup, run and maintain the ledger nodes.\nAbstract #  In current stage, NewChain MainNet would still run with PoA (Proof-of-Authority) consensus mechanism for producing blocks. Hence a certain amount of staking would be required for keeping the ledger nodes honest and not be malicious to harm the network.\nAlso more than a half pre-existing ledger nodes will be kept running in the beginning stage for keeping the network safe for a smooth transition to the next stage.\nOnce a community ledger node is activated, it would start to collect gas fees in the blocks it produces.\nAlso a reasonable split of the daily release of the NewPool will be allocated to reward the ledger nodes proportional to the number of blocks it successfully produced and accepted by the network.\nThe left part of the daily release of the NewPool will be still allocated to reward the virtual \u0026ldquo;community node\u0026rdquo; staking, including the staking by the ledger nodes.\nAccording to the nature of the PoA consensus, all the ledger nodes, including that are run by the community, can vote to include or exclude a certain ledger node to join or leave the newtork, by means of a CLI command or relative NewPay function.\nMotivation #  To improve the openness of NewChain MainNet, involve the community to run the network and benefit from it, create more solid consensus of the whole Newton ecosystem as well as enhance the decentralization of the newtork, this proposal is drafted for the whole Newton community to review and going to implement once reviewed.\nSpecification #  Technical specifications can be found at those documents respectively:\n  newchain-nodes: Deployment manual for setting up a NewChain node.  Implementation #  Adoption of the content of this NEP requires the following steps:\nPhase 0. Dry-run\n The miner should be a qualified NewChain TestNet ledger node first. Any miner who want to participate MainNet mining should create a staking \u0026ldquo;community node\u0026rdquo; in NewPay and lock in AT LEAST 10,000,000 NEW. The miner who want to participate MainNet mining should setup the MainNet ledger node first according to the document above. The miner should prepare a self-introductory information disclosure like below, and submit:  node name: LEDGER-XXX (please change the XXX to your favorite words) staking \u0026ldquo;community node\u0026rdquo; name and staking amount: (as staked in the \u0026ldquo;community node\u0026rdquo; in NewPay) how you will contribute to promote Newton: (please fill the text in the description field in the \u0026ldquo;community node\u0026rdquo; in NewPay)   The joined ledger nodes then vote for new ledger nodes to be involved into the network.  Phase 1. Sustainability\nThe NewPool release allocation program as well as the NewForce program will be upgraded to split the daily released NEW from NewPool to allocate to\n \u0026ldquo;community nodes\u0026rdquo; ; and ledger nodes  Other \u0026ldquo;virtual\u0026rdquo; NewForce mining that are not on-chain verifiable, such as NewMall \u0026ldquo;buy to mine\u0026rdquo;, will be deprecated forever.\nEconomic calculation will be detailed out later soon before phase 1 is to be kicked start.\nPhase 2. Self-Governance\nIn the first stage, the ledger nodes will be coordinated to vote for a new node to join, or a node to leave the network, by means of either\n to ask the nodes to execute a CLI command to vote; or to ask the nodes to click to vote via NewPay.  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':26,'href':'/neps/nep-12/','title':"NewORG Standard (NRC-12)",'section':"NEPs",'content':"Simple Summary #  NewOrg template standard represents the living organization in newton ecosystem and a new DAO paradigm for the next generation social governance and collaboration.\nAbstract #  NewOrg methods and standard based on NewChain and smart contract technologies are defined as is:\n based on NewChain and its smart contract technologies. to replace the traditional limited corporation with new governance paradigm based on blockchain technologies. to define a set of meta rules for organization governance, and clarify the separation of these rules between NewChain layer and contract layer to implement: (1) business irrelative meta rules; (2) flexibility of neworg governance token; (3) anchoring all neworg to NewChain. compatible with staking nodes as well as NewForce incentivization model in current NewPay for easier migration. a complete open standard for any organization, institution, goverments to create NewOrg and transfer the centralized trust to the decentralized infrastructure and trust.  Motivation #  To replace the traditional limited corporation with new governance paradigm based on blockchain technologies, illustrated as below:\n Specification #  Meta Data #  The meta data functions are constant methods that returns information. Parameters all have a leading _.\norgInfo #  returns the informaiton of the Org:\n _name, the name of the Org _type, the type of the Org  1 - Commercial Instituation 2 - Community Group 3 - Government Sector 4 - Non-profit Organization 5 - Developer Community   _description _countryRegion _url, the website of the Org _managementFee, %, ranging 0-100, of mining profits that would be attributed to the Org owner  function orgInfo() public view returns (string _name, uint8 _type, string _description, string _contryRegion, string _url, uint8 _managementFee) totalStaking #  returns the total staking amount of NEW (unit: ISSAC) of the Org.\nfunction totalStaking() public view returns (uint256 _amount) stakingAmountOf #  returns the staking amount of a specific address which is a partner of the Org.\nfunction stakingAmountOf(address _partner) public view returns (uint256 _amount) versionTag #  returns the versionTag (e.g. \u0026ldquo;0.1.0\u0026rdquo;) of the Org.\nfunction versionTag() public view returns (string _versionTag) owner #  returns the owner address of the Org.\nfunction owner() public view returns (address _owner) countOfMember #  returns the count of members of the Org.\nfunction countOfMember() public view returns (uint256 _count) isMember #  returns if the given address is the member of the Org.\nfunction isMember(address _person) returns (bool _isMember) Interaction / Functions #  The interaction functions are methods that would change the states.\nmodifyOrgInfo #  modifies the information of the Org (refer to orgInfo() above).\nfunction modifyOrgInfo(string _name, uint8 _type, string _description, string _contryRegion, string _url, uint8 _managementFee) increaseStaking #  increases the total staking amount for the caller itself.\nfunction increaseStaking() payable increaseStakingFor #  increases the staking amount for someone else.\nfunciton increaseStakingFor(address _stakeholder) payable decreaseStaking #  decreases the staking amount of the caller.\nfunction decreaseStaking() joinOrg #  joins the Org (as the caller).\nfunction joinOrg() exitOrg #  exits the Org (as the caller).\nfunction exitOrg() Rationale #   Asset Token Matrix #  Possible asset tokens could be formulated with the following Boston matrix:\n Test Cases #  TBD\nImplementation #  TBD\nTBD #  Org token is removed from the original version and it should be considered later.\nReferences #   ERC-20 https://eips.ethereum.org/EIPS/eip-20  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':27,'href':'/neps/nep-29/','title':"NewPay Community Node Migration",'section':"NEPs",'content':"Simple Summary #  As part of the NewChain MainNet opening strategy and upgrading plan, the current \u0026ldquo;community nodes\u0026rdquo; in NewPay for virtual mining would be migrated and resolved for paving the way of NewChain to embrace a more bright future.\nThis proposal will illustrate a possible solution for migrating them to be integrated into the NewSwap mining framework to also benefit the development of NewSwap.\nAbstract #  The current \u0026ldquo;community nodes\u0026rdquo; in NewPay are doing \u0026ldquo;virtual mining\u0026rdquo; nowadays for daily released NEW from NewPool. The allocation of NEW are propotional to NewForce gained by each node.\nWith the NewChain opening strategy, ledger nodes run by the community will be involved and rewarded according to blocks they produced respectively.\nNewPay \u0026ldquo;community nodes\u0026rdquo; should be migrated and resolved with regard to a smooth transition plan.\nMotivation #  To facilitate the NewPay \u0026ldquo;community nodes\u0026rdquo; to be migrated and resolved within the planned transition period, this proposal is drafted for the whole Newton community to review and going to implement once reviewed.\nReferences #  References can be found at those documents respectively:\n  Current \u0026ldquo;community nodes\u0026rdquo;: A comprehensive list of the current \u0026ldquo;community nodes\u0026rdquo; as well as the stats.  NewSwap: The official site of NewSwap.  NewAsset Generator: The token issuance tool.  Implementation #  Adoption of the content of this NEP requires the following phases:\nPhase 0. Preparation.\nIn phase 0, several criteria for a \u0026ldquo;community node\u0026rdquo; would be lowered as follows:\n the minimum amount of NEW to be staked for creating a \u0026ldquo;community node\u0026rdquo; will be lowered to 1,000,000 NEW. the minimum required votes for a \u0026ldquo;community node\u0026rdquo; to be elected will be lowered to 0.  The effective date would be officially announced beforehand.\nPhase 1. Migration.\nPhase 1 would include the following steps:\nStep 1. Freeze.\n At a specific date and time announced in advance for at least 20 days, the \u0026ldquo;community node\u0026rdquo; feature will be frozen. No more \u0026ldquo;community node\u0026rdquo; would be allowed to create, and no \u0026ldquo;community node\u0026rdquo; would be allowed to unlock and quit, until the step 2 airdrop is finished. During the frozen period, all \u0026ldquo;community nodes\u0026rdquo; will receive daily mined NEW as usual, until step 2 airdrop.  Step 2. Migrate.\n The owner/creator of each \u0026ldquo;community nodes\u0026rdquo; (referred as \u0026ldquo;the node owner\u0026rdquo;) would be required to calculate the NEW staking amount and issue a token (called \u0026ldquo;cToken\u0026rdquo;) for this node with exactly the same amount of the total supply. NewAsset Generator could be used for this task.  cToken definition: Symbol: 2-4 letters abbreviated from the node name, for example, ABC. Name: the node name. Amount: exactly the same amount with the staking amount of NEW in this node as frozen in step 1. Precision: 18 Mintability: DISABLED. The node owner will then submit an application to NewSwap for joining the Node Mining Area of NewSwap. The node owner would be required to transfer 100% of the issued cToken to NewSwap airdrop address, for being distributed to original node stakeholders through on-chain airdrop, according to the staked NEW in a pro rata basis. All the cToken will be airdropped to each specific person who staked NEW in this \u0026ldquo;community node\u0026rdquo; via either founding/co-founding the node or voting for the node. The \u0026ldquo;community node\u0026rdquo; will be unfrozen, for everyone to unlock the staked NEW immediately. The original NEW mining will be stopped at the same time. The node owner will create a liquidity pool for the cToken paired with NEW and put the cToken and NEW (in a reasonable ratio in your rationale and as you wish) into the liquidity pool and get the LP tokens of cToken-NEW. Each who joins the liquidity pool can then put the cToken-NEW LP tokens into the Node Mining Area of NewSwap for being ready to mine NEW. Later on, the person can read the mining contract to check out the amount of LP tokens he/she owns, and withdraw them as he/she wants.  The roadmap and deadline for this step will be announced before the migration begins.\nStep 3. Yield Farming.\n Once all the \u0026ldquo;community nodes\u0026rdquo; are settled and all cToken-NEW LP tokens are correctly locked up into the mining contract as the announce deadline in step 2, the liquidity mining will be activated. Farmers, i.e. LP token owners, will receive NEW for yield farming. All farmers will share a certain amount of NEW yielded with each block. The amount of NEW received will be decided by the following formula:   locked LP token amount * LP token price against NEW ------------------------------------------------------ * the amount of NEW yielded with a certain block ∑(LP token amount * LP token price against NEW) Please note that the LP token price against NEW will be updated once a day for the performance consideration on the smart contract execution.\nThe mined NEW are generated from NewPool daily release. For more information on the NewPool release, please refer to NEP-27 NewChain MainNet Opening.  Step 4. Join and Leave.\nJoin:\n Prepare a certain amount of NEW, for example, 1,000,000 NEW. Issue a token that will be used as cToken, with the same amount of the NEW in point 1, and the mintability disabled. NewAsset Generator could be used for this task. Create the liquidity pool with cToken:NEW (in a reasonable ratio in your rationale and as you wish) and get all the LP tokens. Submit an application for joining the Node Mining Area. Once it is correctly configured, the applicant can then put his/her LP tokens into the mining contract to start yield farming.  Leave:\n Just simply remove the LP tokens from the mining contract.  Step 5. End.\nAfter 1 year yield farming, the Node Mining Area will be closed.\nCopyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':28,'href':'/neps/nep-22/','title':"Newton Composite Asset (NCA)",'section':"NEPs",'content':"Simple Summary #  Newton Composite Asset (NCA) is the base pattern of asset combination that defines the boundary of how two or more than two assets are combined as a single instance. NCA distinguishes from the other types of asset by involving more than one NEAT. Every NCA is defined based on the principle of Behavioral Equivalence 1, so that unique properties of NCA can be distinguished computationally and therefore maximize the possibility of code reuse and automated asset valuation.\nNCA creates value through patterns of asset composition. By definition of composition, every NCA is a combination of two or more than two NEATs. The required engineering of how combined NEATs can generate more value than their independent existence, a package that is more than the sum of its parts, is a major source for its value creation. Economically speaking, if components of an NCA can be bought or sold separately as independent NEATs, there would be little necessity to bundle them together as an NCA. Therefore, it is the compositional pattern that defines the unique value of the system as a collective makes an NCA more valuable than the sum of its parts. Effectively, NCA is the programmable device to define NEAT Portfolios. From a practical standpoint, NCA is where value can be created via combinatorial possibilities, when validated by marketplace, is a true form of productivity. In general, all NCA are uniquely prescribed by the content of its portfolio. When the portfolio contains any one item that is non-fungible, the portfolio are considered to be a Non-Fungible NCA. If the NCA are composed of assets that are all replaceable, then, the NCA is considered to be Fungible NCA. Furthermore, when NCA can be broken up to divisible portions, they are considered to be Divisible NCA. When they must be sold in complete packages, they are considered to be Non-Divisible.\n Abstract #  Newton Composite Asset (NCA) is an asset class that defines value through a composition of more than one NEAT components. NCA is the generic data type to define \u0026ldquo;smart contracts\u0026rdquo; in Newton Infrastructure, where economical vehicles can be created out of other existing NEAT-based components. It is equivalent to a program composed of many transactional functions that already existed in the trust-worthy platform.\nMotivation #  In contrast to individual NEAT, NCA is composed of multiple NEATs, whose validation and execution of composed transactions must take extra efforts and maintain. Therefore, the value of an NCA should be greater than the sum of its parts. This is also considered to be the way Newton Community can create new value by defining various ways to combine existing sub-classes of NEATs to create new asset classes combinatorially. This is the place where new value can be generated by having creative minded agents and agencies to select meaningful composition of assets, and perform analysis of their combined values. Then, it is up to the creator of the NCA to programmatically define the price and conditions of transaction of all available NEATs across the Newton Community. This allows any agents or agencies in the Newton Community members to contribute their creativity in terms of how to combine NEATs into NCAs.\nIt is well-known that assets have different values in different spatial and temporal contexts. In most well-known marketplaces, goods and services are often sold when needs arise. The realization of value is often passive. For example, the price of umbrella is often more valuable during rainy days, medical equipments can become particularly valuable when certain diseases become a major threat. These contextual valuation is often realized passively, when event arises. However, such pricing approach not only could cause unreasonable price gauging, in most cases, the supply of goods and services could often be incompatible with the actual needs. Since many of these time-based needs can be overlooked in \u0026ldquo;normal days\u0026rdquo;. NCA provides a vehicle to combine resources in a time-bound transaction. Therefore, many of these time-based transactions can be planned ahead of time. So that foreseeable needs can be planned ahead of time in the process of designing NCA. In theory, when needs are anticipated before needs arises, the pricing of needed goods and services would naturally consider the issue of supply chain capability. Therefore, there would be relevant efforts to fulfill the needs as anticipated. In practice, when certain needs repeatedly occur, new classes of NCA would be created as the community learns about the needs in reality. Therefore, the overall community would become more capable in reaching reasonable supply and demand dynamics.\nAsset Valuation Techniques #  Analyzing the values of NCA requires a new breed of simulation tools. Since the market value of asset is bounded to a societal context, and the future of this realistic context always have certain uncertainty. The best possible approach is to provide a common Asset Valuation Simulation platform, so that the value of any NCA will be priced based on the simulation, with participant\u0026rsquo;s private investments or insurance policies.\nUser Experience Design of NCA #  NCA\u0026rsquo;s user interface should have a common base-design. Since all NCA are made of other instances of NEAT-based assets, a common navigation interface must be provided for all NCA. So that user would have a consistent experience in identifying and comparing NCAs.\nImmutability and irrefutability #  Every NCA is a unique combination of NEAT assets. So that once it is created, the compositional content cannot be changed.\nNCA\u0026rsquo;s names in NEAT Namespace #  NCA can be represented as a registered name in NEAT\u0026rsquo;s namespace. It should be a subclass of NEAT, having its sub-Namespace code segment. This unification of NCA in NEAT will significantly reduce the complexity of NCA management.\nSpecification #  As mentioned in NEAT, the foundational building blocks of NCA is NEAT. The composition of NEAT into NCA is based on pi-Calculus. Every NCA is defined as follows:\n NCA, NEAT := Receive asset *a* from Transaction Channel *C*, run NEAT or NCA; Send asset *a* over Transaction Channel *C*, then, run NEAT or NCA; Concurrently Execute NEAT and NCA, and test NCA's composition rules; Create a new Transaction Channle *X*, run NCA; Repeat multiple instances of NCA or NEAT; Terminate all NCA and NEAT transactions;  Syntax and Semantics #  NCA is a composite data structure defined by NEATs or other instances of NCA. As shown above, NCA can be defined recursively. The legitimacy of NCA is defined by the temporal and logical prescription of each NEAT, for example, if certain assets requires the concurrent availability of other collateral assets, such as meat delivery must be accompanied by refrigeration service, then, relevant temporal logic conditions must be satisfied. By embedding logical and temporal conditions within each NCA, the NCA composition is the executable logic that defines whether certain contract is considered fulfilled or breached. NCA can be composed of any number of existing NEATs. For example, it can be a combination of existing NPA (Physical Assets), NBC (Newton-backed Currencies), and NPC (Newton Prepaid-Card). By specifying the asset components of an NCA, it also automatically check the temporal and logical validity of these composited asset, so that all transactions are automatically verified statitically, and dynamically, based on a common data type, NEAT.\nA unique feature of NCA is the creator. Since every NCA spells out a unique composition of asset content, its creator is like an artist/author, that creates a unique portfolio of assets. Therefore, the account, or accounts that create such composition, should be associated with this value creation process, and should be responsible for the rewards and possible damages of this value composition.\nMeta Data #     Item Description Behaviors/Properties     Creation Input     Creator Accounts The Newton Account identities that creates the said NCA deploy/can not be changed   Associated NEATs A list of NEAT involved with this NCA at least one NEAT   Portfolio Rules A composition that describes the quantity and sequence of NEAT/NCA rule should be described in pi-Calculus   Status The status of NCA is can be separated into following kinds: Proposed, Tested, Verified, Executed, Decommissioned a finite set of status classes   ** Evolution History **     Developmental History A list of time points when NCA is created and modified new timestamps are added as changes made   Execution History A list of NCA execution time points, including reference to executed NCAs immutable data records    Rationale #  NCA is a way to leverage compositional efforts to create value. Such compositional value creation can be best illustrated by Bitcoin as a currency. Since Bitcoin as a system creates market value through a composition of three communities, they are:\n A community of Miners: a large number of administratively independent machines, that agrees on a common transaction ledger. A community of Traders: a large number of accounts and agents who are transferring funds between different accounts. A community of Coders: an open sourced community that keeps improving and fixing source code the offers better and more secure software functionalities.  The value of NCA comes from its composition of complementary functions. Separately, each community has relatively limited value constrained by their physical surroundings. Once combined through Bitcoin, or some form of NCA, the credibility of assets and ubiquity of asset liquidity becomes pervasive. Effectively, this three way composition of Miner, Traders, and Coder accounts, brings together a living entity that is distributed across the globe, and works around the clock, unstoppably. Similarly, there will be many forms of assets that can be composed to broaden its value across space and time. The role of NCA as a root class of other NCAs, is to provide a template the covers how asset valuation can be done, how to design user interfaces for other NCAs, and demonstrate the immutable and irrefutable values of assets. Last but not least, the value in Namespace, is the foundation of asset management, and how NCA plays in the Namespace must abide to a set of non-negotiable rules.\nHigh Level Architecture #  NCA is essentially a composed NEAT contract that needs the widest possible reachability to the marketplace. For NCA to exists, it must first be created. The creation process should follow the typical DevOps/CI/CD type development cycle. The DevOps/CICD workflow is often associated with the idea of Event Sourcing, short handed as ES. For trivial combination of NEATs, simple user interface that allows users to combine NEATs into portfolio of NEATs would be a starting point. Once any NCA is created with existing NEATs, a sequence of testing and validation procedure must be applied, so that programmatically detectable conflicts can be first conducted before the created NCA is released to the marketplace.\n It can be thought of as a typical exchange matching engine, when the ask/bid combinations are matched, the transaction would take place. In short, it can be simply considered as a marketplace of NCAs, and they can be bought and sold as if they are listed entries of stock or futures in current market practice. Knowing the transactional nature of NCA, the design of NCA exchange marketplace can be implemented using the existing exchange engine that is commonly designed to execute stock or virtual currency trades. As mentioned earlier, the buyer/seller matching algorithm should be based on some automated algorithms. These algorithms should following the Behavioral Equivalence 1 properties. One way to defining such property is to classify NCAs that are ready to be exchanged in terms of Behavioral Equivalences. So that all transactions can automatically take place based on the pre-processed classification.\nA rather complete architectural diagram based on CQRS-architectural pattern could be referenced to implement the overall system. The diagram was originally created to explain the CQRS-Event Sourcing concept by Daniel Whittaker. Implementation #  There are two aspects of NCA implementation. The first one is NCA creation by combining NEATs. The second one is to release NCAs into a public marketplace to be traded. The first one should be an exercise of user interface design and automated testing. As mentioned in the High Level Architecture, the automated testing should follow priniciples prescribed by [1] Behaviral Equivalence of said NCAs. The testing can be conducted using formal model checking tools such as TLA+ or to be implemented in Coq.\nThe second one is a matching engine that allows traders to quickly search for their desirable NCAs and allow buyers and sellers to easily find their targets. The implementation of matching and transactional engine can be implemented using Event Sourcing and CQRS-based implementation models. For the choice of software stack, Apache-Kafka is a high performance platform that can execute up to millions of transactions per second.\nReferences #  \n Rocco De Nicola, Behavioral Equivalences, [ Research Gate], [ L-Università ta' Malta]  \n Alex Pentland, Alexander Lipton, and Thomas Hardjono, Building the New Economy, [MIT Press]  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':29,'href':'/neps/nep-20/','title':"Newton Encoded Asset Transaction (NEAT)",'section':"NEPs",'content':"Simple Summary #  Newton Encoded Asset Transaction(NEAT) defines the root data type for all asset exchanges. Once a new record of NEAT is registered into Newchain, it represents a form of irrefutable accountability based on the immutable features of Newchain. To help transaction assess the worthiness of transactions before their commitment, all transactions have a common field, called: Bounded Accountability, which defines all known exit conditions when a transactional process is breached. From an economic viewpoint, the security of every transaction must be insured by worthwhile collateral assets, which include the reputation history of the exchange participants. To make transactions trust-worthy, all transactions must be encoded as an executable algorithm, and all human initiated asset exchange execution are authorized by cryptographically ensured procedures. NEAT delivers Bounded Accountability of transactions by representing transactions based on\n trust-worthy timestamps, irrefutable asset identities, non-repudiable agreement actions, deposited collaterals.  NEAT can be seen as a Domain Specific Language (DSL) that is dedicated to represent transactional accountability. The domain represented by DSL is the domain of transactions, since all subsequent transactions are reprented by the root data class, NEAT. More importantly, only NEAT and its subclasses will be recorded on Newchain, which will become durable and accountable in the history of NEAT execution. As a DSL, NEAT provides a small, yet expressive vocabulary of asset types, so that practical business transactions can be composed of NEAT to represent a broad range of economic activities with computable risk profiles with a common field: Bounded Acountability. NEAT presents a small set of asset types as its linguistic primitives. For instance, NewID/NewKYC accounts, NEP-21: Newton Physical Asset, NEP-22: Newton Composite Asset. It is based on these primitives, applications such as NEP-23: NEAT-backed Currency, NEP-24: Newton Prepaid-Card can be defined for practical use. The notion of Buy, Sell, Borrow, and Bid, are the actions or verb primitives of NEAT. The runtime execution of NEAT is carried out by NewKernel, and all transactional records will be immutably stored on Newchain. The following diagram outlines the architecture of the NEAT execution environment.\n Abstract #  Newton Encoded Asset Transaction (NEAT) is a Domain Specific Language (DSL) that represents asset transactions with computable Bounded Accoutability. The goal of NEAT is to provide a rigorous language to construct asset portfoilios on an exchange platform to facilitate asset-sharing practice. NEAT facilitates sharing by always make both providers and receivers of the asset accountable of their actions in terms of bounded collaterals. Every NEAT-based transaction must have computable and verifiable data items that represent the accountability of the transaction participants. In other words, all participants must earn their reputation over time, or they must deposit a reasonable amount of asset to insure their own transactional actions. With Newton\u0026rsquo;s immutable ledger and accounts represented by NewID, accounts with good credit history will be able to carry more trust-worthiness and will be given more freedom in practicing wider ranges of commercial activities. To instill accountability to every NEAT-based transactions, every transaction is associated with the following security features:\n every transaction should be guaranteed by a set of collateral asset, deposited by participants of the transactions or the transaction platform. all transactions must be tagged with secure timestamping services, public keys for participating accounts (NewID and NewID-based NewKYC), globally defined asset identities (IPv6, MAC Address, and other IoT and asset-specific tags) composable semantics of delivery/reception mechanisms based on pi-calculus. Univalence: All NEAT utilizes a unifying security model, the degree of security should be measured by equivalent units, measured in Newton. Newton as a currency is bound to physical time.  NEAT as a DSL for Transactional Operations #  From the highest abstraction level, all transactions are composed of three main types of operations, Selling, Buying and Matching of Buyer/Sellers. These three operations are to be recorded into an immutable transactional datastore, as shown in the following diagram:\n The most common states are listed in the following table:\n   Function Description Permission     Ready for More Transactions Allow additional transactions to be processed on NEAT. System Level   Initiate Transaction Allow NewID accounts to intiate new Transactions NewID Accounts   Seller Ops Create a new offerings to be bought, including credit and offering validations NewID Accounts   Buyer Ops Create a new bid to obtain products or services NewID Accounts   Matching Ops Match Buyer(s) and Seller(s) based on NEAT Contract System Level   Transaction Completion After all commitments are checked, automatically store transaction records on Newchain System Level   Failed Transaction Conditions Terminate Transaction based on contractual conditions. System Level   Bounded Accountability Every NEAT and its subclasses will be associated with one entry of Bounded Accountability System Level (Editable Once by the NewID account of Initiate Transaction)    Technically speaking, NEAT is a domain-specific language with a immutable transaction ledger and a unifying real-world clock. It can be expanded to encode other types of transactions that follows this generic pattern. The main objectives of creating NEAT is about creating a unifying namespace to , so that knowledge derived from operating this transactional ledger can be uniformly shared to improve the soundness and precision of transaction accountability. NEAT as an abstract specification of a DSL in the Domain of Bounded Accountability is not limited to a specific stack of software/hardware technologies. However, NEAT\u0026rsquo;s initial reference implementation will be bound to the archietctual patterns of Serverless Applications, Function as a Service (FaaS), Event Sourcing, Command Query Resposibility Segregation (CQRS), and the process patterns, DevOps, GitOps, and MLOps. These architectural guidelines will limit the technical discussion, and engineering implementation to a specific level of data abstraction, particularly bounded to time-oriented namespace management. This temporally-oriented design principle will permeate the overall engineering efforts, including the design and implementation of human-data interaction interfaces.\nMotivation #  NEAT is about providing a unifying, and formally verifiable data type that represents asset transaction activities on Newchain. The motivation to unify transactional data on one formally verifiable data type is to avoid human intervention without valuable collaterals and maximize knowledge reuse with respect to transaction processing. This data type would allow anyone with a Newchain account to participate in a transparent and unbiased asset transaction service, purely defined by executable logical contracts. The accountability of transactional activities is grounded in Newchain, whose infrastructure provides trust-worthy facts through irrefutable account-based actions and immutable event occurrence sequence. To maximize knowledg reuse, NEAT is defined as the root class for all other types of transaction. Having one unifying base class, provides a discipline to organize and compare the differences between all transaction processing strategies. This unity will significantly reduce the complexity of system development and maintenance, therefore minimize the transaction processing cost (cost of middleman).\nTime-bound ACID Transactions #  A key feature of NEAT is the notion of Bounded Accountability. The security of accountability is to ensure by data security, often prescribed as the ACID properties of transaction, Atomicity, Consistency, Isolation, and Durability. The \u0026ldquo;economic value\u0026rdquo; or transactional accountability is bounded by the \u0026ldquo;correctness\u0026rdquo; of contract execution during runtime. Therefore the correctness is also bounded by a time window, from the time point of contract initiation, up to the point of contract fulfillment or failure acknowledgement. Knowing that Newchain is an non-stoppable real-time immutable data store infrastructure, participants of NEAT-based transactions can judge the boundaries of accountability based on the physically meaningful timestamps, and ACID properties associated with data transactions. All claims of accountability must be follow the consistency in timestamped records to infer their respective judgemental outcomes. Combining this timestamped data with formal data analysis tools, such as the System Specificatin language: TLA+ 9. An abstract specification language such as TLA+, can be used to define the possibility space of accountability in temporal dimensions, and allow the possibility state space to be symbolically enumerated and examined by participants prior to commiting to certain transaction. Therefore, either transaction participants conduct extensive verification processes using formally defined logic, or they simply declare the admission of bounded risks, and therefore agree to the said Bounded Accoutability. By explicitly denoting transactions with a computable field: \u0026ldquo;Bounded Accountability\u0026rdquo;, such data field provides a formal structure to express risk profiles of all transactional activities uniformally. All risks that participants are willing to take can be expressed in a set of objectively defined risk assessment statement executable by temporal logic.\nTemporal Logic Reasoning Engine: Behavioral Equivalence #  To make NEAT pratical, yet pertains sufficient robustness from error, the vocabulary of NEAT, will need to be incrementally refined to fit the changing application contexts. The refinement process will be supported by formal method tools, such as TLA+. Tools such as TLA+ will first denote distinguishable transactional states of transaction activities, and then, use these time-based state notation to classify different kinds of asset transaction activities. This is also where the overall system establish equivalence between transactional processes with different names. Then, these classified transactional activities can be assigned context-dependent terms, and these terms will be managed in a globally managed NEAT reserve word dictionary. This global dictionary of NEAT defines equivalent classes of transactional behavior, so that all transactional behavior will be grounded in the namespace of formal analysis, not in the context-dependent namespace. Grounding all transaction models with a formal behavioral representation allows the NEAT system to evolve around abstract specifications. Concrete implementation and operational data will also be referenced in the overall knowledge base, but they will only serve in a supportive role for evolving the NEAT language.\nVocabulary Management in Wiki #  As NEAT gets applied in operational contexts, natural language synonyms of these formally defined vocabulary will be slowly admitted to the dictionary of alias, published in a distributed wiki database. This wiki database provides a common repository for participants to publish and read the definition of different types of transactional activities. The natural language oriented content of Wiki, allows many kinds of people ,allowing non-technical people to better engage with NEAT. The design and evolution of NEAT, will follow the methodology of Domain Deriven Design(DDD), where the domain is grounded in temporal logic. Knowing that time arrow will always increase entropy, the namespace of NEAT will simply be version controlled using uniquely defined time-stamps on Newchain. In other words, the version control mechanism of NEAT\u0026rsquo;s dictionary is grounded in Newchain\u0026rsquo;s timestamp sequence. This grounding uniquely combines namespace management with the trust-worthy time-stamping service provided by Newchain, an entropy-based namespace management strategy can naturally classify increasingly complex transaction types, and therefore define all the namespace of known transaction types under one unified dictionary. Intentially maintain logical consistency through the use of one trust-worthy timestamp service, the namespace evolution governed by the second law of thermodynamics will provide the cornerstone to unify the developmental approaches to transaction processes. This time-bound namespace management strategy will support an future-proof transactional processing infrastructure that maximally avoid redundancy in the development and maintenance of transaction processing services.\nUser Experience Design surrounds Time, Immutability and Irrefutability #  NEAT is designed to support transactional activities between humans. Therfore, the irrefutability of NEAT can be accepted when human participants can consciously agree with transactional actions and records. Participant awareness is built-in a common user experience design framework by following three key human interaction components:\n Actions defined by a time-bound namespace: Users need to know that all transactional actions are distinguished by a unifying timestamp system. The uniqueness of their actions are guaranteed by an irreversible sequence. Record Immutability: Once finished, all transactional records goes into an \u0026ldquo;immutable\u0026rdquo; state, meaning that NEAT records will never be changed after it is committed. Irrefutable accountability: Once participant agrees to do something at certain time point, the irreversibiliy and immutability of this transaction system make the decision maker accountable for their earlier decision. All decision are final at the time points of transaction execution.  In other words, since all other transactions are defined under the umbrella of NEAT, by designing a set of User Interfaces guidelines to ensure human participants are aware of time, immutability, and irrefutability, the transactional system can be accountably deployed to the public.\nSpecification #  Technically, NEAT is designed as a base transactional language with time-bound trust-worthiness. It defines a set of foundational syntax and vocabulary in a structured namespace, specifically organized in Newton Asset Namespace (NAM). NAM provides a unifying framework to named implementations of encryption algorithms, secure timestamp mechanisms, and account security based on Newchain. By using a formalized namespace to manage the identities of the assets being exchanged, and the secured mechanisms of how this asset is being delivered, NEAT provides a unifying exchange protocol for all asset exchange bookkeeping between its community members. NEAT being the root class of asset transaction records, allows other types of assets to be encoded following or extending the possible definitions of asset transaction activities. This data structure is independent of the particular kind of assets that it is being exchanged.\nNEAT Syntax #  NEAT is a base class that can be extened to make up Newton Composite Asset (NCA), that are composed of multiple instances of NEATs. The syntax for defining composed NEAT and its composed structure, NCA, is based on pi-Calculus. pi-Calculus is the formalism of encoding processes and their interactions as a rewrite system. Every NEAT is defined as follows:\nNCA, NEAT := Receive and Send asset a from Transaction Channel C, run NEAT or NCA; Concurrently Execute NEAT and NCA; Create a new Transaction Channle X, run NCA; Repeat multiple instances of NCA; Terminate all NCA transactions; More detail of NEAT syntax will be explained in NEP-22: Newton Composite Asset, because data asset is compositional in nature, and the data content of a NEAT is almost always composed of other data types.\nNEAT Semantics #  The uniqueness of NEAT is defined by a combination of transactional channel C, asset a, time t, and a hashcode of Executing Condition h(E). In practice, all NEAT must have access to collaboral asset CA, and a set of reimbusement rule RR given different conditions during breach of contract. The meaning of the variable names mentioned above are defined here:\n   Variable Name Annotation Explaination     NEAT NEAT_p, NEAT_q represents distinct instance of NEAT named transactions based on the unique combination of C(x,y), a, t (Time), and a Hashcode of Executing Conditions   C(x,y) Account names: (Issuing Account)+ \u0026ldquo;:\u0026rdquo; (Receiving Accounts)+ The direction of asset transfer: x Issuing Accounts -\u0026gt; y Receiver Accounts   a Asset IDs : (Asset ID)_ \u0026ldquo;:\u0026rdquo; (Asset ID)_ a represents the set of (Asset ID)* to be transferred to from x to y   t Time: (Newchain timestamp)+ A sequence of timepoints of actual transactional events marked by (Newchain timestamp)+   E Executing Conditions: (Deliver Condition)+ \u0026lsquo;:\u0026rsquo; (Reception Condition)+ (Deliver Condition)+ \u0026lsquo;:\u0026rsquo; (Reception Condition)+ are two set of rules that defines the delivery and reception conditions of asset right transfer. Maybe associated with timestamp information shown in (3).   CF Comment Field: (Natural Language content that describes the contract) A field dedicate for human understanding, like the Ricardian Contract. The comments of NEAT can be written in a formatted template, the format could follow Logic Model.   CA Collateral Asset: (Asset ID)+ Collateral asset as a guarantee for participants of this transaction. This is usually defined by the insurance policy for the amount of resources to be issued to participants when transactions failed. (Asset ID)+ should be a set of transferrable assets that will be ditributed in case the transaction fails. Initially, this can be certain amount of Newtons made available to insure the risk coverage of possible transaction failure modes.   RR Reimbursement Rules: (Rule for Reimbursement)+ A contract explicitly defines how to reimburse the participants when the transaction failed to work. The allocation of funds should be independent of the creator of this NEAT type. (Rule for Reimbursement)+: An automated executable contract, written in scripts that would allocate the available cryptographically ensured funds to participants according to various deliver/reception status. The creator of the executable contract should demonstrate that they are NOT in positions of conflict of interest.    Human Interface Design #  Since all subsequent information are subclasses of NEAT data and its organized by a unifying logical clock. It would be necessary to present a unifying user interface to present these temporal data at different scales. The design method can consider the formalism presented by Chris Stolte et al, in their Multiscale Data Cubes approach 8(http://graphics.stanford.edu/papers/pan_zoom/paper.pdf).\nExplicit Guarantees #  The value guaranteed by NEAT can be supported by the following explicit guarantees:\n Collateral Assets: all NEAT should have assets dedicated to guarantee the integrity of the transaction. Prior Transaction Records: the historical records of how the identical or similar NEAT was executed with immutable historical data. Mechanized Proofs: The \u0026ldquo;Executing Conditions\u0026rdquo; is the explicit contract that spells out the boundary conditions of how transactions are fulfilled. It should be accompanied by a set of testable conditions, that has an accompanying mechanized proof program to statically check the logical integrity of \u0026ldquo;Executing Conditions\u0026rdquo;. Overtime, the \u0026ldquo;Executing Conditions\u0026rdquo; can be enriched based on operational data to avoid any conflict of interests. Strength of Cryptographic Protection: The system assumes that account actions are initiated by agents who didn\u0026rsquo;t lose their passwords or their cryptographic system are asserted to be in tact. For low risk and low value transactions, cryptographic systems with lower degree of security can be guaranteed by having some form of collabteral assets.  By allowing these three types of explicit guarantees, the value of each NEAT is protected and transaction data recorded on the chain. This also helps to isolate the dependencies between different NEAT, in case some transactions or businesses caused any suspectable results, their problems can be totally independent from other NEAT. The overarching idea is to accommodate all levels of security and asset guarantees based on a lattice-based security classification system. In other words, the levels of guarantee are given a consistent lattice-based namespace to make the risk exposure to be explicit.\nRationale of Bounded Accountability #  The acountability of NEAT transactions are insured by a set of complementary mechanisms, such as security levels characterized in cryptographics, the amount of deposited collaterals, and the algorithmic properties of mechanized proofs. All transactions are assume to only carry risk levels up to the parameterized boundary, therefore, having a set of certified human-machine interfaces, and the relevant computable implementations of Bounded Accountability are essential features of NEAT. When assets are considered to be more valuable than the representable insurance policy, these mechanisms, including human-machine interfaces should prevent assets to be engaged in a NEAT transaction. This protective mechanism works both for the human participants, as well as the NEAT operating infrastructure. On the side of human participants, NEAT exchange should only be initiated after certain security deposit or prior reputation can cover the allowed Bounded Accountability. On the operational side, by parameterizing risk profiles in terms of computable/decidable terms, it becomes possible to automatically assess a large number of transactions in a wide range of application contexts. In other word, the notion of Boundary is determined by the computability of risk parameters. Without presenting risk profiles in terms of computationally representable and effectively computable expressions, it would be impossible to ochestrate the astronomical volume and types of transactional activities that can be automatically conducted using currently existing Internet of Things infrastructure.\nBalancing Security Protection Pragmatically #  The above mentioned guarantee mechanisms together form a mutually dependent protection ecology. A NEAT without the protection of sound cryptographic security system, or it doesn\u0026rsquo;t have an automatically verifiable proof, the participants should not put down too much Collateral Assets to guarantee the specific NEAT transaction. On the other hand, when the maturity of NEAT \u0026ldquo;executable conditions\u0026rdquo; are throughly tested both operationally with historical records, and mechanical proof results, then, it would be much likely that such NEAT is going to deserve larger amount of collateral assets. The key idea is that NEAT is a platform to allow participants to dynamically construct a bounded security using existing infrastructure, without waiting for all four conditions to reach perfection.\nFreedom in Constructing Transactional Contracts #  The transactions of digitally representable assets can be best illustrated by the four fundamental rights as explained by Richard Stallman\u0026rsquo;s \u0026ldquo;Free Software, Free Society\u0026rdquo;[ available here].\n   Free Software pi-Calculus Concept     The right to use Software The choice to engage certain interactive process (Human choose to use certain piece of software)   The right to understand the working mechanisms of Software Parallel execution of the software, including mirror the understanding of the working principles   The right to modify the software for other Uses Change the software in ways that covers the way it didn\u0026rsquo;t work before (Prohibit or enable certain new functions)   The right to re-distribute the modified Software Replicate the software/data asset in alternative distribution channels (Re-distribution for profit)    Leveraging the fundamental rights to the four composable rules, one can define a way to cover a wide range of data asset transaction scenarios that have been investigated for decades by prior luminaries, such as Richard Stallman, Robin Milner, and Leslie Lamport.\nImplementation #  High Level Architecture Design Principles #  NEAT as a generic format of transaction, is the data structure that controls the states for all asset transfer. It is also an extensible programming language with a particular application domain. Its syntax, semantics and pragmatics can be defined using formal language modeling tools, such as the K Framework. Overtime, the system does NOT need be bound to specific tools or speicific implementations. For example, NEAT can be implemented using hand coded C, or automatically generated code modeled on K Framework. NEAT\u0026rsquo;s underlying time-oriented data store, do not necessarily need to be bound to blockchain-based transaction model. Any transaction model that fulfills the notion time-based Bounded Accountability, as specified by the abstract specification will be admitted. This document is intended to be written as an implementation neutral specification, that can be examined in terms of abstract logical arguments, not in terms of the run time performance of engineering artifacts. Therefore, this document is intentionally written as an abstract specification of NEAT, and its implementation should be separated from this specification. At the same time, NEAT is also an operational platform, it needs to leverage existing engineering wisdom and tools that has already demonstrated scalability and technical sophistication. So that the following section will present the guidance in implementing a scalable NEAT infrastructure.\nEvent Sourcing, CQRS, and DDD #  Since NEAT is highly depedent on time, the software implmentation strategy should be aligned with known architectural patterns that provides time-sensitive data structures. For example, to implment concurrent systems, adopting event sourcing 10 patterns such as CQRS 10 (Command Query Resposibility Segregation), and define transactions in terms of their business domains using DDD (Domain-driven Design), are high level architectural designs that do not directly involve coding. By separating design from implementation has many long term advantages, and allow implementation decisions to be based on architectural arguments, not based on implementation details.\nThe focus of NEAT is all about secure real-time transactions, that means performance is of utmost critical concern. Using design patterns such as Event Sourcing, it is possible to better investigate broadly applicable design solutions without involving source code level experiments. More importantly, it allows implementers to systematically search for industrial strength solutions that are designed to solve these fundamental, system-level issues, such as security, high performance, irrefutable transaction processing. Even if these technical solutions are solved by our own implementation, it should be organized as a generic tool that can be reused in other projects.\nTo manage data at scale, NEAT will follow an architectural guideline that separates the overall system into two planes, namelythe Control Plane and Data Plane. The purpose of separating data from the controlling mechanism is to embrace the convention in the Cloud Native movement. Separating systems into composable modules made of meshed services. The origin of this idea of Control Plane vs. Data Plane was popularized by Istio\u0026rsquo;s Service Mesh architecture. However, this high level division of responsibilities is a useful guideline. The matching classification to NEAT and Newton\u0026rsquo;s namespace is shown as below.\n Continuous Workflow in evolving NEAT #  Implementing a programming language is about testing hypothesis of adopting various vocabulary in the expanding application contexts. Therefore it is a continuous learning process, and requires certain guidance in keeping pace of such wide open context of learning. A model to keep workflow in check is the well known Khun Cycle, similar to most Continuous Integration and Continuous Delivery/Deployment (CICD/CD) workflow. The term CI/CD is also very much tied to the notion of DevOps, as \u0026ldquo;Development\u0026rdquo; of new code base must be tightly integrated with the way data services are being \u0026ldquo;Operated\u0026rdquo;. The bluring of boundaries between model development and model operation is an inevitable trend as the cycle time of source code evolution is turing at a speed that can only be captured by having the entire development and deployment process run on a fully automated workflow. This fast-evolving idea of code evolution is compatible with the notion of Kuhn Cycle. The key concern in Kuhn Cycle is the idea of acquiring new vocabulary when the system reaches or identifies \u0026ldquo;immcommensurability\u0026rdquo; in its operating experience (problems detected through Data Plane). By applying CICD and being mindful of Kuhn\u0026rsquo;s vocabulary detecting/collecting Cycles, NEAT will become a living engine that is capable of learning and implementing new ideas. In other words, NEAT is designed as a community-based programming language, its own evolutionary cycles should follow a governance model that is similar to the experience of develping new versions of the NEAT language. In other words, NEAT aims to openly invite anyone to participate in the definition of a transaction processing language that is version controlled by a distributed timestamp system. Vocabulary has value, publically accepted vocabulary has measurable value. Ideally, the new NEAT types are new \u0026ldquo;models\u0026rdquo; learned from operational data, sometimes automatically learned through formal method tools or machine learning workflows. In the case of Newchain, since operational data are immutable data, capturing data content with \u0026ldquo;real\u0026rdquo; timestamps. These immutable and publicly revealed data can be the ideal grounding data for MLOps, as the Machine Learning enabled version of DevOps.\nControl Plane (Dev) #  Newton Community\u0026rsquo;s Infrastructure will carry the responsibility of offering the controlling mechanisms of non-repudiability and irrefutability trace. Newton Community demonstrate its service security through the liveness and safety of its \u0026ldquo;service mesh\u0026rdquo;, or the \u0026ldquo;Controlling Mechanism\u0026rdquo; of the operational data. Using this framework, a significant amount of existing code base can be leveraged for use immediately. In the Istio Architecture, the controlling mechanism for security is often called: \u0026ldquo;Citadel\u0026rdquo; component. Using existing code base that already has been tested by industrial strength solutions will drive the total amount of data to be processed through Newton Infrastructure.\nData Plane (Ops) #  The role of NEAT data type is to provide a typing classification scheme for ongoing implementation of specific asset types. Therefore, the focus of NEAT is to become a template, the unifying implementation to ensure the subsequent classes of application specific asset type could enjoy the same level of data security. From an practioner\u0026rsquo;s viewpoint, overtime, NEAT should have a significant number of application specific subtypes, such as the initally planned NEP-23: NEAT-Backed Currency and NEP-24: Newton Pre-paid Card . As the specific sub-types grow in number, more specific applications will have their own tailor-made data types. However, as the sub-type grow in number, the possible errors and potential redundancy will naturally dissipate attention and therefore increase the cost of source code quality maintenance. Therefore, the idea here is to design NEAT as the unifying data type for a programming language. A language specific dedicated to distributed transaction processing engine. Then, the vocabular adopted overtime, could be reused throughout the community, and even over the entire Internet. This way, we can encourage reuse of the high-level architecture. In other words, the Data Plane of NEAT is a dictionary for other implementation. We will design NEAT as a Domain Specific Language that can be customized and extended to other application specific languages. Then, the likelihood of having patterns in NEAT, such as NEAT-backed Currency (NBC) and NPC to be reused could be hidden in the implementation, so that the technical properties can be preserved. It is expected that implementers will add features within their own applications, and by managing the vocabulary as the Data Plane for a service system, we can alleviate some risks in being drawn to serve many design goals. Thereshould be only one unifying set of design goals in NEAT, that is to ensure system correctness, via safety and liveness concerns. Data security represent safety, and Performance features enables liveness possibilities.\nNamespace Management with Formal Methods and Industry Practices #  NEAT as a transaction protocol should define its namespace using Formal Methods and tools. For example, the critical terms, such as Transaction Initial Condition and Ending Conditiion, should be listed as reserved words using tools such as TLA+ to examine their tempoal logic possibilities. The namespace practice should not be only dependent on committee-based voting procedure, but it must include the analysis model of temporal dynamics, and then, use the analysis model as a collateral to support the decision for expanding or reducing the namespace of NEAT. NEAT should adapt open source software tools that has been extensively tested in known industrial applications. For example, for high throughput transactions, NEAT could adopt well-known messaging systems, such as Apache Kafka to implement Byzantine Fault Tolerance through a more flexible and higher bandwidth transaction engine. In certain cases, it is reasonable to identify third party solution providers to implement or offer high performance solutions that satisfies the abstraction functional specifications. For example, Axon Framework as a solution framework could be a starting point to address implementation issues. Regardless of which software framework to be adopted, NEAT will wrap an implementation-neutral Application Programming Interface (API) based on the abstract specifcation, so that NEAT will remain independent from specific implementation detail through API Namespace management. By orchestrating namespace in a unified fashion within NEAT specification, software developers and infrastructure operation providers can offer their services through the notions of FaaS (Function as a Service), Cloud Native Data Services, and Serverless applications, so that NEAT can be completely abstracted away from specific implementation and hardware maintenance.\nSecurity Considerations #  Every NEAT type should be a totally isolated container of its own risks. Every subtype of NEAT will define an equivalent class of risk as measured by our Control Plane. Therefore, the assets associated with the NEAT type should be defined as a bounded liability, so that its risk factors are isolated from the other parts of Newton infrastructure.\nThe Mechanisms of Proofs #  Every sub class of NEAT must go through a rigorous process to demonstrate that risks are divided into explicitly defined namespaces. The techical term is called identifying \u0026ldquo;Behavioral Equivalence\u0026rdquo;. Assets that can be exchanged through the same kind of transactional mechanisms, should use the same \u0026ldquo;class\u0026rdquo; of NEAT contract. The security features of each NEAT contract should be proven through the software development process. Certain anecdotal thinking can be found in Steiner\u0026rsquo;s blog entry 5. However, to reach a more rigorous level of security, NEAT should try to prove and approve every new subclass following formal methods as described in Rosu\u0026rsquo;s paper 6. Rosu also leads the K Framework development, which is a rewrite-based language design model that can be used to define and verify formal properties of any language. The argument that NEAT must be designed as a proto-language can be traced back to the legend of Tower of Babel, see  7. By having a sound and unifying linguistic root for all transactions, it will significantly broaden the application areas, and more importantly, reduce the risk the risks of misinterpretation, and increase the overall security of the entire transactional system. The working mechanism of proofs are managed in a namespace known as types of NEAT, so that all risk factors can be first reasoned in the categories, or types of risks, before committing to real world applications.\nWhat is a proof in NEAT? #  A proof in NEAT is to show that the contract will do what it claim to do under all possible circumstances.\nIf one only show that all past run time records have all satisfied the contract conditions, the data cannot complete a proof, because future events might break the system. Therefore proof can be done by going through certain automated abstractions. Automatic proof mechanisms have been made available for a while, certain commercial services (Inventor of K Framework, Rosu, created a start up to run mechanized proofs for blockchain contracts.) are also available to help verify \u0026ldquo;smart contract\u0026rdquo; on blockchain infrastructures. The point here is that NEAT should instill an internal mechanism to include certain assets to be allocated for writing and examing proofs. By including an overhead for proving integrity of NEAT contract will instill a new level of security in the design of NEAT system.\nThe dependency or logical sequences of proofs can be displayed as diagrams, also known as proof net. The process of submitting a new NEAT sub class is similar to the workflow of submitting a new piece of source code. The key contribution of Newton Technical Review Board is to provide a secure mechanism to insure irrefutability and provide quality control mechanisms that have been \u0026ldquo;proven\u0026rdquo; over time in the public domain. When uncertain conditions are met, the Newton Review Board will resort to explicit classification, and define a category of risk based on known data. By naming and classifying risks, it will provide significant reuse of intellectual labor to analyze the quality of proposed new NEAT subclasses, and therefore increase the quantity of transactions.\nBackwards Compatibility #  All NEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The NEP must explain how the author proposes to deal with these incompatibilities. NEP submissions without a sufficient backwards compatibility treatise may be rejected outright.\nTest Cases #  All test cases of NEAT should be classified into two kinds:\n Safety tests: examining conditions for when the contract execution will not cause undesirable situations. Liveness tests: examining conditions for when contract execution will ensure something desirable would actually happen.  The safety and liveness tests should be created based on tools such as Static Analysis and TLA+ and other similar test case generation tools.\nTest cases for NEAT should first be conducted on dedicated Newton Test Chain, so that the compatibility of the system could be managed between the two systems.\nReferences #  \n Leslie Lamport, Time, Clocks, and the Ordering of Events in a Distributed System, Communications of the ACM, July, 1978.  \n Richard Stallman, Free Software, Free Society, Free Software Foundation, 2002, PDF  \nRobin Milner, The Polyadic Pi-Calculus a Tutorial, October, 1991  \nChris Newcombe, et al., How Amazon Web Services Uses Formal Methods, Communications of the ACM, April, 2015.  \n Jutta Steiner. Security is a process: A postmortem on the parity multi-sig library self-destruct, 2017  \nGrigore Rosu, Formal Design, Implementation and Verification of Blockchain Languages, Paper (University of Illinois), Slides (University of Waterloo), Video (Youtube)  \n Alex Gendler, How languages evolve, Ted Ed video  \n Chris Stolte, Diane Tang, Pat Hanrahan, Multiscale Visualization Using Data Cubes, PDF  \n Leslie Lamport, Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineering, Addison Wesley  \nDominic Betts Julián Domínguez Grigori Melnik Fernando Simonazzi Mani Subramanian  \n Alex Pentland, Alexander Lipton, and Thomas Hardjono, Building the New Economy, MIT Press  \n Urbit: A Decentralized Personal Server Platform, Wikipedia  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':30,'href':'/neps/nep-21/','title':"Newton Physical Asset (NPA)",'section':"NEPs",'content':"Simple Summary #  Newton Physical Asset (NPA) is the base class of physical asset classes. NPA requires certain proof mechanisms to be included as a part of guarantee to allow transaction of ownership. Two basic types of proof must be made available:\n Proof of Existence: The asset must provide some mechanism to show the asset exists, such as some online API to show that certain goods or services physically exist, that responded with some provable existence message. Proof of Ownership: This mechanism must provide certain information that shows the goods or services of interest can be traded under Newton accounts.  Besides the notion of Existence and Ownership, physical assets are further divided into two broad categories, often called: Movable/Personal and Immovable/Real Estate Properties. These asset terms are commonly used in legal and accounting practice, and will be adopted by NPA\u0026rsquo;s namespace management. However, under the accounting classification of Movable Properties, a special category called Intangible Property such as copyrights, brand names, or patents, are not considered a subclass of NPA. Intangible Property is to be classified as subclasses of Named Asset in the inheritance hierarchy of NEAT data types.\n Abstract #  Newton Physical Asset (NPA) is the base asset class that uses executable contract to guarantee the existence and ownership rights of physical assets. Knowing that the cybernetic world and the physical world could exist discrepancies, NPA attempts to approximate the existence and ownership proofs using a combination of four things: Proof of Stake, Soundness Analysis, Precision Analysis, and Time-bound Proofs. These four strategies of proving ownership and existence of physical goods provide a negotiation platform for all Newton account owners to engage with transactions. The design and evolution of NPA will follow the concepts originally developed in property law[1], where the basic rights associated with properties are broadly classified as: Rights to possession, use, manage, income generated, capital, and transmissibility. These rights applies to all assets, including non-physical assets. For NPA specific asset classes, Movable and Immovable assets are distinguished. Then, within Movable Assets, Consumable, Durable, and Interest Generating assets are classified. Within Immovable Assets, Owned and Leased Assets are the two main classes. These classifications are designed to offer time-based distinctions of relationships between assets and accounts.\nMotivation #  The key idea in NPA is to establish provable relationships between accounts and the physical piece of assets. NPA\u0026rsquo;s main design motivation is to leverage the cryptographically-protected account system with a trust-worthy timestamp data service and existing proof of stake insurance policies to secure NPA related transactions. In other words, the key idea of NPA is to unify the overarching framework rooted in NEAT. NPA helps to reduce costs of negotiation by introducing automated reasoning mechanisms about the claims of existence and ownership through Soundness Proofs, Precision Assessment[4], and Newton\u0026rsquo;s secure timestamp system.\nReuse Code by Sharing Expertise across the Supply Chain Management Industry #  Instead of requiring all NPA issuers to learn formal methods and speak in terms of Soundness, Precision, and time security. NPA will work with the standard vocabulary established in the supply chain industry, and primarily focus on proof mechanisms that are related to existence and ownership proofs. By translating the vocabulary from technical domains to supply chain domain, we can separate the work between the two professions. NPA issuers can search for existence and ownership proof in their business specific requirement language, and relevant soundness and precision reasoning mechanisms will be categorized in business terms to help NPA issuers to customize and compose existing executable code to support their needs. Once a new set of executable \u0026ldquo;smart\u0026rdquo; contract has been tested and proven to work in the marketplace with live data, the code can be shared to similar business practices across the Newton Community. Therefore, it is crucial to keep an abstract vocabulary to describe NPA, so that code reuse can be maximized.\nUser Interface for NPA #  When exchanging physical goods, buyers and sellers are likely to perform both sending and receiving roles interchangeably. A reason for the bi-directional sending and receiving functions on both buyer and seller sides is because physical goods might be returned or send back for repair or replacement. Therefore a set of user interfaces that define existence and ownership with precise time bounds on both ends become a significant driver in broadening user base.\nThe strategy for designing user interface of NPA is to insure that roles of sending and receiving are categorized into a set of functional specifications, so that the \u0026ldquo;skin\u0026rdquo; of the user interfaces can be attached to those standardized functional specifications interchangeably. By defining a set of generally applicable functional specifications for delivery and reception verification, NPA will be relatively easy to target many application contexts without having to reinvent the wheels everytime a new, but similar business model is created. This will also help Newton Community to reach a larger community base within a shorter amount of time.\nNon-repudiation Features #  Once certain physical goods are delivered or received, it is necessary to make sure that senders and receivers will not repudiate their reception or sending status. To minimize these possible information conflicts, repudiation resolution process should be designed as a measurable cost component, so that anyone who decides to go through a repudiation process, the system will automatically assign risk factors to parties who breached the repudiation contracts.\nNPA knowledge as a source of income #  Any vendors or buyers submitting bug reports or prescribe solutions to any of the above mentioned problems, will be automatically given credits or be rewarded of their contribution. The more of their cases being adopted and used as a resolution for future cases, the more credit they will receive. Buying and consuming as actions, will naturally accumulate operational data, and data can provide information and potential wisdom to better refine the overall framework of physical good exchange. An explicit reward mechanism will incentivize participants to actively contribute their intellect to help build up a better NPA transaction rule base.\nSpecification #  NPA should use NEAT as the basis of transaction model, which implicitly leverages secure timestamping services built-in Newton Infrastructure. Then, all physical goods must work with Newton Asset Namespace (NAM), so that a unifying namespace could be leveraged to reference known types of physical goods.\nThe existence and ownership status of physical items, should be bounded to existing industry standards or publicly verifiable data sources. Each of these existence and data precision qualities should be bounded to version controlled automatic analytical algorithms that defines the soundness and precision claims. Unless these self-administrating features are provided, no NPA should be issued.\nSyntax and Semantics #  The data structure and the meaning of transactional physical items should also be defined using ideas derived from pi-Calculus. This section inherits all features of NEAT, with the additional records that defines existence and ownership statuses.\n   Syntax Semantics     Account names: (Issuing Account)+ \u0026ldquo;:\u0026rdquo; (Receiving Accounts)+ The direction of asset right transfer: Issuing Accounts -\u0026gt; Receiver Accounts   Asset IDs : (Asset ID)_ \u0026ldquo;:\u0026rdquo; (Asset ID)_ The first set of (Asset ID)_ provides asset to be transferred to Receivers' (Asset ID)_   Time Slots: (Newchain timestamp)+ A sequence of timepoints of actual transactional events marked by (Newchain timestamp)+   Conditions: (Deliver Condition)+ \u0026lsquo;:\u0026rsquo; (Reception Condition)+ (Deliver Condition)+ \u0026lsquo;:\u0026rsquo; (Reception Condition)+ are two set of rules that defines the delivery and reception conditions of asset right transfer. Maybe associated with timestamp information shown in (3).   Comment Field: (Natural Language content that describes the contract) A field dedicate for human understanding, like the Ricardian Contract. The comments of NEAT can be written in a formatted template, the format could follow Logic Model.   Collateral Asset: (Asset ID)+ Collateral asset as a guarantee for participants of this transaction. This is usually defined by the insurance policy for the amount of resources to be issued to participants when transactions failed. (Asset ID)+ should be a set of transferrable assets that will be distributed in case the transaction fails. Initially, this can be certain amount of Newtons made available to insure the risk coverage of possible transaction failure modes.   Reimbursement Rules: (Rule for Reimbursement)+ A contract explicitly defines how to reimburse the participants when the transaction failed to work. The allocation of funds should be independent of the creator of this NEAT type. (Rule for Reimbursement)+: An automated executable contract, written in scripts that would allocate the available cryptographically ensured funds to participants according to various deliver/reception status. The creator of the executable contract should demonstrate that they are NOT in positions of conflict of interest.   Existence : (Rule for existence)+, (identity of physical item), (existence status) A list of rules stating how to judge the existence of certain name-identified physical item, in a set of defined existence status. (Assessment of Existence)+: A set of Soundness and Precision assessment algorithms defined in executable formats in Newton Infrastructure.   Ownership status: (Owner Account)+, (Rule for ownership status)+ A list of rules that defines the owners' identity, and a their ownership status of the above mentioned physical items in the existence field. (Assessment of Ownership)+: A set of Soundness and Precision assessment algorithms that can automatically check ownership status of the mentioned physical items in Newton Infrastructure.    Interaction / Functions #     Function Description Behaviors/Properties     Receivers Add Issuing Account to the collection of accounts that can create and modify the executable contract in the form of NEAT. permission: owner   Senders transfer owner of this executable contract to other Newton Accounts permission: owner   CreateNewToken Create a new instance of NEAT token from this contract    AddMemberBySubscribe Add participating members to the collection of Newton accounts that can transfer or receive data representable assets in the specification defined by NEAT. permission: contract   RemoveMember Remove participating members permission: owner/admin   Initiate Transaction Initiate transaction based on contractual conditions. permission: contract   Exit Transaction Terminate Transaction based on contractual conditions. permission: contract    Rationale #  The transactions of digitally representable assets can be best illustrated by the four fundamental rights as explained by Richard Stallman\u0026rsquo;s \u0026ldquo;Free Software, Free Society\u0026rdquo;[ available here].\n   Free Software pi-Calculus Concept     The right to use Software The choice to engage certain interactive process (Human choose to use certain piece of software)   The right to understand the working mechanisms of Software Parallel execution of the software, including mirror the understanding of the working principles   The right to modify the software for other Uses Change the software in ways that covers the way it didn\u0026rsquo;t work before (Prohibit or enable certain new functions)   The right to re-distribute the modified Software Replicate the software/data asset in alternative distribution channels (Re-distribution for profit)    Leveraging the fundamental rights to the four composable rules, one can define a way to cover a wide range of data asset transaction scenarios that have been investigated for decades by prior luminaries, such as Richard Stallman, Robin Milner, and Leslie Lamport.\nBackwards Compatibility #  All NEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The NEP must explain how the author proposes to deal with these incompatibilities. NEP submissions without a sufficient backwards compatibility treatise may be rejected outright.\nTest Cases #  All test cases of NEAT should be classified into two kinds:\n Safety tests: examining conditions for when the contract execution will not cause undesirable situations. Liveness tests: examining conditions for when contract execution will ensure something desirable would actually happen.  The safety and liveness tests should be created based on tools such as Static Analysis and TLA+ and other similar test case generation tools.\nTest cases for NEAT should first be conducted on dedicated Newton Test Chain, so that the compatibility of the system could be managed between the two systems.\nSecurity Considerations #  Every NEAT type should be a totally isolated container of its own risks. Every subtype of NEAT will define an equivalent class of risk as measured by our Control Plane. Therefore, the assets associated with the NEAT type should be defined as a bounded liability, so that its risk factors are isolated from the other parts of Newton infrastructure.\nThe Mechanisms of Proofs #  With modern Internet of Things (IoT) Infrastructure, many physical goods and services can attain multi-party, or independent sources of existence proof or ownership proof. Massively manufactured online sensors and actuators usually come with a Media Access Control Address (MAC address), these kind of information can provide the unique identities and locations of information validity. Couple with a distributed timestamp, which will be provided by Newchain, a time-bound security mechanism can be established to validate the proof. In NPA, we suggest the use of static analysis techniques, such as Abstract Interpretation [ 1] to perform Soundness and Precision Analysis. The notion of Soundness and Precision must be interpreted abstractly, meaning that the quality of NPA should be judged by how well the NPA presents \u0026ldquo; sound\u0026rdquo; judgement and \u0026ldquo;precise\u0026rdquo; approximation [ 2], as defined in static analysis tools, independent from the concrete execution of product transaction activities. All subclasses of NPA should follow the Soundness and Precision definition presented in this document, so that every NPA\u0026rsquo;s risk profile can be assessed based on these formally defined characteristics.\nEvery sub class of NEAT must go through a rigorous process to demonstrate that risks are divided into explicitly defined namespaces. The technical term is called identifying \u0026ldquo;Behavioral Equivalence\u0026rdquo;. Assets that can be exchanged through the same kind of transactional mechanisms, should use the same \u0026ldquo;class\u0026rdquo; of NEAT contract. The security features of each NEAT contract should be proven through the software development process. Certain anecdotal thinking can be found in Steiner\u0026rsquo;s blog entry[ 5]. However, to reach a more rigorous level of security, NEAT should try to prove and approve every new subclass following formal methods as described in Rosu\u0026rsquo;s paper: [6]. Rosu also leads the K Framework development, which is a rewrite-based language design model that can be used to define and verify formal properties of languages, such as security related properties. The working mechanism of proofs are managed in a namespace known as types of NEAT, so that all risk factors can be first reasoned in the categories, or types of risks, before committing to real world applications.\nReferences #    Alison Clarke, Paul Kohler, Property Law: Commentary and Materials, Cambridge University Press, 2006\n   Alex Pentland, Alexander Lipton, and Thomas Hardjono, Building the New Economy, MIT Press\n   Patrick Cousot, Abstract Interpretation, Website\n  Bertrand Meyer, Soundness and Completeness: With Precision, Blog@CACM, April 20, 2019, Web, Web\n  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':31,'href':'/neps/nep-24/','title':"Newton Pre-paid Card (NPC)",'section':"NEPs",'content':"Simple Summary #  Newton Pre-paid Card (NPC) is a cryptographically insured asset that works with exchangeable assets within the Newton Community. It can be extended to issue Membership Card, Score Cards, or even Balanced Score Cards. It can also possess negotiating powers in attaining tangible goods. For example, one may pre-pay for editable goods, such as vegetable, milk, or beef, or other kinds of commercially viable goods. The basic assumptions about NPC is that it provides a classification scheme to define goods. The two immediate categories are Membership Cards and Tangible Goods. These two classes are both sub-classes of Pre-Paid Card. The remaining subdivisions can be visualized in the following Class Diagram.\n Abstract #  Newtoin Pre-paid Card (NPC), is a divisible asset type that can be used to claim rights to group membership, or to claim ownership to tangible goods. The classification of rights should follow certain programmable contracts. NPC as an asset type is to serve as a template for many other classes of assets. Therefore, the development of NPC is not about operating a particular membership or selling tangible goods, it is about providing a general asset classification guideline to use a smaller common base classes to handle many cases of asset transaction for its sub-classes of goods and services. On the other hand, the purpose of NPC is to help Newton Community to best reuse data management technologies and mechanisms for asset transactions. For example, due to practical needs and regulatory concerns, there should be a certain difference in managing edible goods vs. non-edible goods. Therefore, there should be a publicized set of asset classes, encoded as two subclass branches. By explicitly managing the types of various contracts, Newton Infrastructure can better support the whole community to share knowledge in using Newton Community\u0026rsquo;s trust-worthy computing infrastructure. Initially, NPC assumes a single-inherentance class structure. Common interfaces between two non-directly inheritance branches can share APIs through the \u0026ldquo;interface\u0026rdquo; mechanism.\nThe collateral asset to guarantee values of NPC follows the original policies of NEAT. All Pre-paid Card should not only accept payment from buyers who want to own Newton Pre-paid Card, every NPC should come with an insurance policy that have a significant amount of collateral asset locked in a re-imbursement pool in case of contract breach conditions.\nMotivation #  The driving force behind NPC is to establish a standarized naming framework for managed assets. Currently, pre-paid good a services are mostly guaranteed by providers' brand recognition and customer\u0026rsquo;s willingness to risk their investment in exchange for advertised discounted prices. This human-trust mechanism basically leaves consumers to bare risks without any guarantee. Through the design of NPC, risks of different types of goods and services can be classified in our naming convention. Overtime, as real operational data reveals battle-ground situations for different types of goods and services, the contracts can evolve accordingly to capture the operational experience as learned data. It is crucial to emphasize that the Newton Technical Commitee is about designing a reusable framework to best support efficient business practices, it is not about operating actual services and good delivery. This position distinguishes the system design from profit making to community supporting. NPC wants as many types of membership groups, various kinds and large amounts of tangible goods to be bought and sold on the Newton Platform, so that all technical decisions for NPC must be vendor neutral.\nSpecification #  NPC is a subtype of NEAT, so that it will automatically inherit all the features of NEAT. The unique feature of NPC, is in its name, the notion of customer pre-payments. In other words, a significant amount of commercial risk is being shared by customers who pay ahead of time. To become eligible as an issuer of NPC, creator of NPC must demonstrate that they have the ability to deliver the announced services and goods. This process is almost identical to the process of \u0026ldquo;crowd funding\u0026rdquo;. Therefore, the qualification procedure that reveals the capabilities of potential capabilities of NPC issuer is the basis of NPC.\nFor service providers, such as club membership NPC issuer, history or proposed services must be articulated and presented as a part of the process to propose an NPC. Similarly, product providers should illustrate the types, qualities, and quantities of goods that certain vendor is capable of providing, so that they can offer to sell pre-paid cards. From NPC\u0026rsquo;s technical viewpoint, NPC\u0026rsquo;s nature is a publishing service for vendors to reveal their goods and services. The main security features of NPC is to show that all data concerning goods and services are irrefutably presented by the receiver of pre-paid assets. Establishing a content submission and account receivable channel, and make sure that both customers and vendors know that Newton only provides an irrefusable communication channel is the technical scope of NPC. In other words, NPC is not about designing a crowd funding website, NPC is about creating a irrefuable proof mechanism between vendors and potentially pre-paying customers. The focus of NPC is the security mechanism, not the product/service specific functionality.\nBeside focusing on security and irrepudiability, NPC also needs to provide guidelines to explain how to classified goods and services. Membership Cards often defines a given duration to service access, while Tangible Goods often defines rights to claim ownership. The technical focus of NPC is to show that each type of services and products might need a slightly different composition of verification API. For example, Membership Cards might need a time-based API, for verifying the validity of services. Where Tangible Goods might need an inventory checking API to see if certain goods are still available or not. These kinds of differences defines the types, so that NPC can give a common classification to different composition of status verification API. By offering a meaningful classification structure, more people can use NPC.\nSyntax and Semantics #  Here, pi-Calculus will play a major role in defining these interactions. For example, Membership Card would define a set of conditions, that illustrates the four basic components of:\n Choice of service package. Each given a name Parallel composition of service tracks Refusal or Prevention of certain services or event from occurence, (i.e. Non-Smoking) Replication of service Stopping of service.  By defininig a general set of service names, all Membership Cards can use the same vocabulary to define their service terms, so that Newton Infrastructure can be the technical provider of these service negotiation data, not the guarantor of these services.\nThe same syntax and semantics works for Tangible Goods. For example:\n Choice of products and amount defined by units and names of products Parallel composition of Product Delivery Refusal to certain products given certain composition. Replication of Products. Terminating product ownership status.  A set of programming interface will be defined for each of the two main subclasses, and all other services and products will follow this template to define other contracts.\nRationale #  NPC being a financial instrument, it must have some grounding rule to be acceptable by the broadest possible audience. The key idea is the notion of equality, to be explained in the term: Univalent Principle.\nUnivalent Foundation #   Univalent Foundation is a type-based mechanism to identify equivalence. Since data security and system integrity is achieved under a common transaction processing language NEAT, every NPC here is a type of transaction, and every instance of transaction should follow the same set of constraining rules. That gives a \u0026ldquo;equivalent\u0026rdquo; kind of fairness to all transaction. Having said that, it means all NPCs must strive to demonstrate certain objective fairness and security through its design. A starting point is to deposit certain amount of asset that reaches publicly agreements, then, all transactions can happen given that insurance asset is available to guarantee fairness. Other forms of fairness should be provided and tested prior to a release of any NPC. The reason being that any breached contract could cause significant social and economical damage to the system, therefore, a unifying safety procedure must be presented and followed for all systems.\nNPC\u0026rsquo;s unique functions #  NPC differs from other transactions in a sense that services and products are not directly controllable by the Newton Infrastructure. Therefore, the risks that incurred here must be somehow contained within the boundaries of the vendor that created their brand of NPC. The total amount of assets to be offered in exchange of pre-payments must have certain Univalent Principles to be automatically checked by the system. Otherwise, it would render the system to carry the risks for the NPC offering vendors, that is clearly not feasible.\nTherefore NPC must offer the following guarantee to its customers:\n Certain amount of deposit that ensures customer satisfaction. Minimal amount of deposit must fulfill conditions of Byzantine Fault Tolerance. Complete certain testing cycles before releasing to the public. Testing cycle will collect operational data, and this data must be revealed to its potential customers. NPC should have a screening procedure for its customers. Customers who is willing to participate must demonstrate certain level of data literacy before they are allowed to issue the initial down payment. Customers who enter the NPC agreements should agree to the reimbursement strategies prior to participation, so that potential conflicts can be minimized. All subtypes of NPC should strictly follow this agreement, otherwise, we will not be able to achieve Univalence, therefore breaching the system correctness assumptions as shown in NEAT.  Deployment Concerns #  The proper way of seeing NPC is to think of it as a class of financial future. It provides an abstract mechanism to allow vendors to receive payment prior to delivery of services or goods. This time difference is a privilege, and therefore will induce risks on customers. Newton\u0026rsquo;s technology infrastructure is to provide vendors who deserve this opportunity to issue a financial future, while offer a technological platform to inform customers of risks at the earliest possible times.\nReferences #    Leslie Lamport, Time, Clocks, and the Ordering of Events in a Distributed System, Communications of the ACM, July, 1978.\n  Robin Milner, The Polyadic Pi-Calculus a Tutorial, October, 1991\n  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':32,'href':'/cla/','title':"Newton Project Individual Contributor License Agreement",'section':"Home",'content':"Thank you for your interest in Newton Project (\u0026ldquo;Newton Project\u0026rdquo;). In order to clarify the intellectual property license granted with Contributions from any person or entity, Newton Project must have a Contributor License Agreement (\u0026ldquo;CLA\u0026rdquo;) on file that has been signed by each Contributor, indicating agreement to the license terms below. This license is for your protection as a Contributor as well as the protection of Newton Project and its users; it does not change your rights to use your own Contributions for any other purpose.\nYou accept and agree to the following terms and conditions for Your present and future Contributions submitted to Newton Project. Except for the license granted herein to Newton Project and recipients of software distributed by Newton Project, You reserve all right, title, and interest in and to Your Contributions.\n1. Definitions #  \u0026ldquo;You\u0026rdquo; (or \u0026ldquo;Your\u0026rdquo;) shall mean the copyright owner or legal entity authorized by the copyright owner that is making this Agreement with Newton Project. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \u0026ldquo;control\u0026rdquo; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026ldquo;Contribution\u0026rdquo; shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to Newton Project for inclusion in, or documentation of, any of the products owned or managed by Newton Project (the \u0026ldquo;Work\u0026rdquo;). For the purposes of this definition, \u0026ldquo;submitted\u0026rdquo; means any form of electronic, verbal, or written communication sent to Newton Project or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Newton Project for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \u0026ldquo;Not a Contribution.\u0026rdquo;\n2. Grant of Copyright License #  Subject to the terms and conditions of this Agreement, You hereby grant to Newton Project and to recipients of software distributed by Newton Project a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works.\n3. Grant of Patent License #  Subject to the terms and conditions of this Agreement, You hereby grant to Newton Project and to recipients of software distributed by Newton Project a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed.\n4. Authorization #  You represent that you are legally entitled to grant the above license. If your employer(s) has rights to intellectual property that you create that includes your Contributions, you represent that you have received permission to make Contributions on behalf of that employer, that your employer has waived such rights for your Contributions to Newton Project, or that your employer has executed a separate Corporate CLA with Newton Project.\n5. Original Creation #  You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which you are personally aware and which are associated with any part of Your Contributions.\n6. No Support Obligation #  You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.\n7. Licensed Works #  Should You wish to submit work that is not Your original creation, You may submit it to Newton Project separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which you are personally aware, and conspicuously marking the work as \u0026ldquo;Submitted on behalf of a third-party: [named here]\u0026rdquo;.\n8. Notification #  You agree to notify Newton Project of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\nPlease sign:\nName:\nDate:\n"});index.add({'id':33,'href':'/neps/nep-7/','title':"Non-Fungible Token Standard (NRC-7)",'section':"NEPs",'content':"Simple Summary #  A standard interface for non-fungible tokens, also known as deeds.\nAbstract #  The following standard allows for the implementation of a standard API for NFTs within smart contracts. This standard provides basic functionality to track and transfer NFTs.\nWe considered use cases of NFTs being owned and transacted by individuals as well as consignment to third party brokers/wallets/auctioneers (“operators”). NFTs can represent ownership over digital or physical assets. We considered a diverse universe of assets, and we know you will dream up many more:\n Physical property — houses, unique artwork Virtual collectables — unique pictures of kittens, collectable cards “Negative value” assets — loans, burdens and other responsibilities  In general, all houses are distinct and no two kittens are alike. NFTs are distinguishable and you must track the ownership of each one separately.\nMotivation #  A standard interface allows wallet/broker/auction applications to work with any NFT on Ethereum. We provide for simple NRC-7 smart contracts as well as contracts that track an arbitrarily large number of NFTs. Additional applications are discussed below.\nThis standard is inspired by the NRC-6 token standard and builds on two years of experience since NEP-6 was created. NEP-6 is insufficient for tracking NFTs because each asset is distinct (non-fungible) whereas each of a quantity of tokens is identical (fungible).\nDifferences between this standard and NEP-6 are examined below.\nSpecification #  The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.\nEvery NRC-7 compliant contract must implement the NRC7 and ERC165 interfaces (subject to “caveats” below):\npragma solidity ^0.4.20; /// @title NRC-7 Non-Fungible Token Standard /// Note: the ERC-165 identifier for this interface is 0x80ac58cd. interface NRC7 /* is ERC165 */ { /// @dev This emits when ownership of any NFT changes by any mechanism.  /// This event emits when NFTs are created (`from` == 0) and destroyed  /// (`to` == 0). Exception: during contract creation, any number of NFTs  /// may be created and assigned without emitting Transfer. At the time of  /// any transfer, the approved address for that NFT (if any) is reset to none.  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); /// @dev This emits when the approved address for an NFT is changed or  /// reaffirmed. The zero address indicates there is no approved address.  /// When a Transfer event emits, this also indicates that the approved  /// address for that NFT (if any) is reset to none.  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); /// @dev This emits when an operator is enabled or disabled for an owner.  /// The operator can manage all NFTs of the owner.  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); /// @notice Count all NFTs assigned to an owner  /// @dev NFTs assigned to the zero address are considered invalid, and this  /// function throws for queries about the zero address.  /// @param _owner An address for whom to query the balance  /// @return The number of NFTs owned by `_owner`, possibly zero  function balanceOf(address _owner) external view returns (uint256); /// @notice Find the owner of an NFT  /// @dev NFTs assigned to zero address are considered invalid, and queries  /// about them do throw.  /// @param _tokenId The identifier for an NFT  /// @return The address of the owner of the NFT  function ownerOf(uint256 _tokenId) external view returns (address); /// @notice Transfers the ownership of an NFT from one address to another address  /// @dev Throws unless `msg.sender` is the current owner, an authorized  /// operator, or the approved address for this NFT. Throws if `_from` is  /// not the current owner. Throws if `_to` is the zero address. Throws if  /// `_tokenId` is not a valid NFT. When transfer is complete, this function  /// checks if `_to` is a smart contract (code size \u0026gt; 0). If so, it calls  /// `onERC721Received` on `_to` and throws if the return value is not  /// `bytes4(keccak256(\u0026#34;onERC721Received(address,address,uint256,bytes)\u0026#34;))`.  /// @param _from The current owner of the NFT  /// @param _to The new owner  /// @param _tokenId The NFT to transfer  /// @param data Additional data with no specified format, sent in call to `_to`  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable; /// @notice Transfers the ownership of an NFT from one address to another address  /// @dev This works identically to the other function with an extra data parameter,  /// except this function just sets data to \u0026#34;\u0026#34;.  /// @param _from The current owner of the NFT  /// @param _to The new owner  /// @param _tokenId The NFT to transfer  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable; /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE  /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE  /// THEY MAY BE PERMANENTLY LOST  /// @dev Throws unless `msg.sender` is the current owner, an authorized  /// operator, or the approved address for this NFT. Throws if `_from` is  /// not the current owner. Throws if `_to` is the zero address. Throws if  /// `_tokenId` is not a valid NFT.  /// @param _from The current owner of the NFT  /// @param _to The new owner  /// @param _tokenId The NFT to transfer  function transferFrom(address _from, address _to, uint256 _tokenId) external payable; /// @notice Change or reaffirm the approved address for an NFT  /// @dev The zero address indicates there is no approved address.  /// Throws unless `msg.sender` is the current NFT owner, or an authorized  /// operator of the current owner.  /// @param _approved The new approved NFT controller  /// @param _tokenId The NFT to approve  function approve(address _approved, uint256 _tokenId) external payable; /// @notice Enable or disable approval for a third party (\u0026#34;operator\u0026#34;) to manage  /// all of `msg.sender`\u0026#39;s assets  /// @dev Emits the ApprovalForAll event. The contract MUST allow  /// multiple operators per owner.  /// @param _operator Address to add to the set of authorized operators  /// @param _approved True if the operator is approved, false to revoke approval  function setApprovalForAll(address _operator, bool _approved) external; /// @notice Get the approved address for a single NFT  /// @dev Throws if `_tokenId` is not a valid NFT.  /// @param _tokenId The NFT to find the approved address for  /// @return The approved address for this NFT, or the zero address if there is none  function getApproved(uint256 _tokenId) external view returns (address); /// @notice Query if an address is an authorized operator for another address  /// @param _owner The address that owns the NFTs  /// @param _operator The address that acts on behalf of the owner  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise  function isApprovedForAll(address _owner, address _operator) external view returns (bool); } interface ERC165 { /// @notice Query if a contract implements an interface  /// @param interfaceID The interface identifier, as specified in ERC-165  /// @dev Interface identification is specified in ERC-165. This function  /// uses less than 30,000 gas.  /// @return `true` if the contract implements `interfaceID` and  /// `interfaceID` is not 0xffffffff, `false` otherwise  function supportsInterface(bytes4 interfaceID) external view returns (bool); } A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02. interface NRC7TokenReceiver { /// @notice Handle the receipt of an NFT  /// @dev The NRC7 smart contract calls this function on the recipient  /// after a `transfer`. This function MAY throw to revert and reject the  /// transfer. Return of other than the magic value MUST result in the  /// transaction being reverted.  /// Note: the contract address is always the message sender.  /// @param _operator The address which called `safeTransferFrom` function  /// @param _from The address which previously owned the token  /// @param _tokenId The NFT identifier which is being transferred  /// @param _data Additional data with no specified format  /// @return `bytes4(keccak256(\u0026#34;onERC721Received(address,address,uint256,bytes)\u0026#34;))`  /// unless throwing  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4); } The metadata extension is OPTIONAL for NRC-7 smart contracts (see “caveats”, below). This allows your smart contract to be interrogated for its name and for details about the assets which your NFTs represent.\n/// @title NRC-7 Non-Fungible Token Standard, optional metadata extension /// Note: the ERC-165 identifier for this interface is 0x5b5e139f. interface NRC7Metadata /* is NRC7 */ { /// @notice A descriptive name for a collection of NFTs in this contract  function name() external view returns (string _name); /// @notice An abbreviated name for NFTs in this contract  function symbol() external view returns (string _symbol); /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC  /// 3986. The URI may point to a JSON file that conforms to the \u0026#34;ERC721  /// Metadata JSON Schema\u0026#34;.  function tokenURI(uint256 _tokenId) external view returns (string); } This is the “NRC7 Metadata JSON Schema” referenced above.\n{ \u0026quot;title\u0026quot;: \u0026quot;Asset Metadata\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Identifies the asset to which this NFT represents\u0026quot; }, \u0026quot;description\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Describes the asset to which this NFT represents\u0026quot; }, \u0026quot;image\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.\u0026quot; } } } The enumeration extension is OPTIONAL for NRC-7 smart contracts (see “caveats”, below). This allows your contract to publish its full list of NFTs and make them discoverable.\n/// @title NRC-7 Non-Fungible Token Standard, optional enumeration extension /// Note: the ERC-165 identifier for this interface is 0x780e9d63. interface NRC7Enumerable /* is NRC7 */ { /// @notice Count NFTs tracked by this contract  /// @return A count of valid NFTs tracked by this contract, where each one of  /// them has an assigned and queryable owner not equal to the zero address  function totalSupply() external view returns (uint256); /// @notice Enumerate valid NFTs  /// @dev Throws if `_index` \u0026gt;= `totalSupply()`.  /// @param _index A counter less than `totalSupply()`  /// @return The token identifier for the `_index`th NFT,  /// (sort order not specified)  function tokenByIndex(uint256 _index) external view returns (uint256); /// @notice Enumerate NFTs assigned to an owner  /// @dev Throws if `_index` \u0026gt;= `balanceOf(_owner)` or if  /// `_owner` is the zero address, representing invalid NFTs.  /// @param _owner An address where we are interested in NFTs owned by them  /// @param _index A counter less than `balanceOf(_owner)`  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,  /// (sort order not specified)  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256); } Caveats #  The 0.4.20 Solidity interface grammar is not expressive enough to document the NRC-7 standard. A contract which complies with NRC-7 MUST also abide by the following:\n Solidity issue #3412: The above interfaces include explicit mutability guarantees for each function. Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure. Your implementation MUST meet the mutability guarantee in this interface and you MAY meet a stronger guarantee. For example, a payable function in this interface may be implemented as nonpayble (no state mutability specified) in your contract. We expect a later Solidity release will allow your stricter contract to inherit from this interface, but a workaround for version 0.4.20 is that you can edit this interface to add stricter mutability before inheriting from your contract. Solidity issue #3419: A contract that implements NRC7Metadata or NRC7Enumerable SHALL also implement NRC7. NRC-7 implements the requirements of interface ERC-165. Solidity issue #2330: If a function is shown in this specification as external then a contract will be compliant if it uses public visibility. As a workaround for version 0.4.20, you can edit this interface to switch to public before inheriting from your contract. Solidity issues #3494, #3544: Use of this.*.selector is marked as a warning by Solidity, a future version of Solidity will not mark this as an error.  Rationale #  There are many proposed uses of Ethereum smart contracts that depend on tracking distinguishable assets. Examples of existing or planned NFTs are LAND in Decentraland, the eponymous punks in CryptoPunks, and in-game items using systems like DMarket or EnjinCoin. Future uses include tracking real-world assets, like real-estate (as envisioned by companies like Ubitquity or Propy). It is critical in each of these cases that these items are not “lumped together” as numbers in a ledger, but instead each asset must have its ownership individually and atomically tracked. Regardless of the nature of these assets, the ecosystem will be stronger if we have a standardized interface that allows for cross-functional asset management and sales platforms.\n“NFT” Word Choice #  “NFT” was satisfactory to nearly everyone surveyed and is widely applicable to a broad universe of distinguishable digital assets. We recognize that “deed” is very descriptive for certain applications of this standard (notably, physical property).\nAlternatives considered: distinguishable asset, title, token, asset, equity, ticket\nNFT Identifiers #  Every NFT is identified by a unique uint256 ID inside the NRC-7 smart contract. This identifying number SHALL NOT change for the life of the contract. The pair (contract address, uint256 tokenId) will then be a globally unique and fully-qualified identifier for a specific asset on an Ethereum chain. While some NRC-7 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a “black box”. Also note that a NFTs MAY become invalid (be destroyed). Please see the enumerations functions for a supported enumeration interface.\nThe choice of uint256 allows a wide variety of applications because UUIDs and sha3 hashes are directly convertible to uint256.\nTransfer Mechanism #  NRC-7 standardizes a safe transfer function safeTransferFrom (overloaded with and without a bytes parameter) and an unsafe function transferFrom. Transfers may be initiated by:\n The owner of an NFT The approved address of an NFT An authorized operator of the current owner of an NFT  Additionally, an authorized operator may set the approved address for an NFT. This provides a powerful set of tools for wallet, broker and auction applications to quickly use a large number of NFTs.\nThe transfer and accept functions’ documentation only specify conditions when the transaction MUST throw. Your implementation MAY also throw in other situations. This allows implementations to achieve interesting results:\n Disallow transfers if the contract is paused — prior art, CryptoKitties deployed contract, line 611 Blacklist certain address from receiving NFTs — prior art, CryptoKitties deployed contract, lines 565, 566 Disallow unsafe transfers — transferFrom throws unless _to equals msg.sender or countOf(_to) is non-zero or was non-zero previously (because such cases are safe) Charge a fee to both parties of a transaction — require payment when calling approve with a non-zero _approved if it was previously the zero address, refund payment if calling approve with the zero address if it was previously a non-zero address, require payment when calling any transfer function, require transfer parameter _to to equal msg.sender, require transfer parameter _to to be the approved address for the NFT Read only NFT registry — always throw from unsafeTransfer, transferFrom, approve and setApprovalForAll  Failed transactions will throw, a best practice identified in ERC-223, ERC-677, ERC-827 and OpenZeppelin’s implementation of SafeERC20.sol. ERC-20 defined an allowance feature, this caused a problem when called and then later modified to a different amount, as on OpenZeppelin issue #438. In NRC-7, there is no allowance because every NFT is unique, the quantity is none or one. Therefore we receive the benefits of ERC-20’s original design without problems that have been later discovered.\nCreating of NFTs (“minting”) and destruction NFTs (“burning”) is not included in the specification. Your contract may implement these by other means. Please see the event documentation for your responsibilities when creating or destroying NFTs.\nWe questioned if the operator parameter on onERC721Received was necessary. In all cases we could imagine, if the operator was important then that operator could transfer the token to themself and then send it – then they would be the from address. This seems contrived because we consider the operator to be a temporary owner of the token (and transferring to themself is redundant). When the operator sends the token, it is the operator acting on their own accord, NOT the operator acting on behalf of the token holder. This is why the operator and the previous token owner are both significant to the token recipient.\nAlternatives considered: only allow two-step NERC-6 style transaction, require that transfer functions never throw, require all functions to return a boolean indicating the success of the operation.\nERC-165 Interface #  We chose Standard Interface Detection (ERC-165) to expose the interfaces that a NRC-7 smart contract supports.\nA future EIP may create a global registry of interfaces for contracts. We strongly support such an EIP and it would allow your NRC-7 implementation to implement NRC7Enumerable, NRC7Metadata, or other interfaces by delegating to a separate contract.\nTest Cases #  TBD\nImplementations #  TBD\nReferences #   ERC-721 Non-fungible Token Standard. https://eips.ethereum.org/EIPS/eip-721 ERC-165 Standard Interface Detection. https://eips.ethereum.org/EIPS/eip-165 NRC6 Token Standard. https://github.com/newtonproject/NEPs/edit/main/NEPS/nep-6/index.md  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':34,'href':'/neps/nep-47/','title':"Parameter Updates on Community Node and vote",'section':"NEPs",'content':"Simple Summary #  This proposal contains parameter changes on community node mining, including NEW staking period, mining reward calculation, and minumam lock amount.\nAbstract #  Changes on NewPay:\n Change NEW staking period on community node and vote. Change minumam lock amount on community node and vote to 10000 NEW. Change community node NF factor to 1, same as community vote NF factor.  Motivation #  NewChain MainNet ledger nodes are open to public since NEP-27 has been implemented. According to NEP-40, Newton community has more posibilities to participate in Newon ecosystem and get rewards. NEP-45 provides an incentive plan for ledger nodes to make sure the Newton network is more open and stable.\nNEP-27, NEP-40, and NEP-45 has been implemented. This proposal is made in order to make Newton network more open and more equitable, to motivate Newton community to participate in the ledger nodes bookkeeping, liquidity mining, which are mentioned in NEP-40, and to increase the liquidity of NEW.\nThe proposal is designed to reduce the complexity of the management of community nodes in the Newpay App, and enable all community members to join in the Newton Incentive Plan freely. Therefore, community participants are encouraged to use their NEW to participate in all Newton Incentive Programs, including but not limited to Newpay Community Node Mining, ledger Node Mining, and liquidity mining.\nSpecification #  Changes on staking rules of community node and community vote #  Community node vote could add or reduce staking at any time, specifically the following below:\n Allow community node owners (including partner node owners) create or quit a node at any time, add or reduce staking at any time. Allow community node members (including partner node members) join or quit a node at any time, add or reduce staking at any time. Allow community node voters vote or quit a node at any time, add or reduce staking at any time.  The following rules remain same:\n Added/reduced staking NEW is effective after 24 hours, which means the changed part of NEW will not be counted in NewForce reward.  Changes on NEW unlock periods of community node and community vote #   Community node owners (including partner node owners) unlock period changes from 7 days to 0 day, which means unlocked NEW will be returned immediately. Community node members unlock period changes from 7 days to 0 day, which means unlocked NEW will be returned immediately. Community node voters unlock period changes from 7 days to 0 day, which means unlocked NEW will be returned immediately. Allow partner node owners could quit and unlock NEW at any time. The partner node will be removed when all partners quitted.  Minimum staking amount #   Changes minimum staking amount of community node from 1000000 NEW to 10000 NEW Changes minimum staking amount of partner node owner from 1000000 NEW to 10000 NEW Changes minimum staking amount of partner node member from 1000000 NEW to 10000 NEW The minimum staking amount of community vote remains same as 10000 NEW  Changes on community node mining NewForce factor #   Change community node NewForce factor from 2 to 1 Community vote NewForce Factor remains same as 1 Change community node additional NewForce factor from vote from 1 to 0  Explanation:\n All staking NEW will be calculated equally. Each 10000 NEW staking everyday will get 1 NewForce. The original intensions of these changes above is aligning all amounts and periods on community mining to keep it equal, simple and clear.  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':35,'href':'/neps/nep-19/','title':"Physical Commodity Standard (NRC-19)",'section':"NEPs",'content':"Simple Summary #  A standard interface for Physical Commodity token\nAbstract #  This template mainly uses the block chain encryption and non tampering features to verify the ownership, capital flow, receipt confirmation and other information of the physical Commodity involved in the production and circulation process, and synthesizes the information flow, capital flow and logistics flowing in the whole process of raw material suppliers, producers, channel agents, dealers and consumers through the block chain technology There is a sound system of credit value flow. The traditional production, supply and marketing system, which focuses on logistics and capital flow, is upgraded to the supply chain credit system, which solves the credit construction problem of physical Commodity in the process of production and circulation, and realizes the traceability and tracking of goods.\nFrom manufacturing to circulation, the essence of commodities is the process of continuous interaction and confirmation among raw material suppliers, manufacturers, channel agents, distributors and consumers of information flow, capital flow and logistics, and the core of which is the supply chain system. Efficient lubrication of the supply chain system will greatly reduce the time cost and capital cost of enterprises, and improve the production efficiency of enterprises. To achieve such an efficient and lubricated supply chain system, the key is to establish a supply chain credit system, which is the key to improve production efficiency and capital efficiency, and reduce production, logistics and storage costs. The traditional solution mainly depends on the contract signed by all parties, so the contract becomes the core element for the related parties to confirm the ownership and income. The tamperable blockchain technology makes it possible to create a new paradigm of credit system under the condition of new technology. A complete blockchain credit system includes not only the individual credit of each industrial subject (such as legal registration, compliance operation, quality certification system, bank credit, etc.), but also the business reputation established by upstream and downstream manufacturers in the supply chain in the actual business cooperation, which can be fully reflected in the blockchain and cannot be tampered with.\nMotivation #  There are mainly two stages in the process of commodity from scratch to consumers' purchase.\nThe first stage is the production stage, mainly from raw materials to production, to channel agents or distributors. The main problem in this stage is the supply chain, and the core body is the producer. Specifically, it includes the long period of signing the manufacturer\u0026rsquo;s contract (purchase of raw materials and sales to channel agents or distributors), the uncertainty of the time when raw materials are transported to the factory, the high cost of raw materials storage, and the large capital pressure.\nThe second stage is the circulation stage, and the core body is channel agents or distributors, who directly face individual consumers. Their main problems are that they occupy a large amount of capital, have a weak control over capital efficiency and liquidity, and have a high storage cost.\nIn addition, for consumers, it is difficult to have objective and real data to prove the source, quality and value of the purchased Commodity. It is necessary to collect necessary data through the whole traceability system of the Internet of things, and confirm it through the tamperability of the blockchain.\nA credible commodity needs not only reliable raw material supply, but also reliable manufacturers and sellers. In this way, it can not only ensure the high credibility of commodities, but also ensure the credibility of circulation links.\nEach manufacturer or business in the industrial chain is responsible for its own product quality, forming a product credit island. A complete blockchain credit system running through raw material suppliers, producers, channel agents (distributors) and consumers can fundamentally solve the problems concerned by all parties in the industrial chain. Any entity in the industrial chain can confirm its upstream and downstream manufacturers or merchants in the blockchain, realize interactive verification, and then form the blockchain credit system.\nSpecification #  The most important document in the transaction of physical commodity is the purchase contract between the buyer and the seller. The contract will specify the quantity, specification, model, unit price, total price, payment method and other important information of this transaction.\nThe establishment of physical commodity supply chain credit system mainly includes the following attributes.\n  Physical properties ofcommodity: brand, product name, specification and model, production date, warranty period, precautions, etc., especially the relevant data collected through the Internet of things are more authoritative and credible.\n  Manufacturers and merchants: brand, trademark, qualification, process standard, etc.\n  Certification certificate of the third party organization: such as quality management system, safety management system, inspection and test report.\n  Government competent / regulatory authorities: such as industrial and commercial registration documents, tax documents, customs documents, etc\n  According to the role of commodity production and circulation, the subject attribute is defined, and the product or commodity attribute is defined according to the subject.\n  Raw material supplier: sign raw material supply and marketing contract according to the manufacturer\u0026rsquo;s demand order, and provide raw materials with quality and quantity as agreed in the contract. Its main attributes include: Industrial and commercial registration documents, qualification documents, qualification documents, inspection and testing reports, quality assurance system, production standards, management system and main processes. Its raw material properties include: Specification and model, quality inspection report, main technical indicators, precautions, etc. In terms of agricultural products, tea, flowers, fruits and vegetables, the raw material supplier also refers to the main body of breeding, and its main attributes also include the weather data related to temperature, humidity, precipitation, fertilization and irrigation during the breeding process. The data form includes video, which can be real-time or non real-time.\n  Product manufacturer: according to the production plan, sign the raw material supply and marketing contract with the raw material supplier, and pay the corresponding amount to the raw material supplier. According to the needs of channel agents or distributors, sign sales contracts with them, collect payment for commodity and provide goods. Its main attributes include: Industrial and commercial registration documents, qualification documents, qualification documents, inspection and testing reports, quality assurance system, production standards, management system and main processes. Its commodity attributes include: Specification and model, quality inspection report, main technical indicators, precautions, etc.\n  Channel agent or distributor: sign supply and marketing contract with commodity manufacturer, pay for commodity, and promote sales to consumers. Collect payment from consumers and provide them with commodity and services. Its main attributes include: Industrial and commercial registration documents, qualification documents, qualification documents, inspection and testing reports. Its commodity attributes include: Specification and model, quality inspection report, main technical indicators, precautions, etc.; its operation attributes include information of goods on and off the shelf, marketing activities, discounts, points, etc.\n  Logistics service provider: an enterprise that provides logistics services in raw materials, commodities, retail and other links. Its main attributes include: Industrial and commercial registration documents, qualification documents and qualification documents. Its service attributes include data information in the logistics process, such as cargo location information, expected delivery information, transporter information, and, if necessary, temperature, humidity and other information in the vehicle body.\n  Consumers: place orders with dealers, pay for goods and purchase commodity. In addition to personal information, it also includes return and exchange information, payment and refund information, receiving information, complaints, etc.\n  In the process of commodity production and circulation, the core users are producers and channel agents / distributors. With the extension of the supply chain, the ownership of raw materials and commodities will also be transferred with the execution of corresponding contracts. That is to say, a complete and reliable commodity blockchain, in addition to the main physical properties of this commodity, should include the blockchain of raw materials or products of its upstream major suppliers.\nMeta Data #     Item Description Behaviors/Properties     Owner Create Commodity Token    Commodity Commodity Info.：TokenId、Contracts、URL、Partners token: raw material suppliers, manufacturers, channel agents, distributors。     Interaction / Functions #     Function Description Behaviors/Properties     Mint Create Commodity Token permission：Owner   Transfer transfer own to Partners NEW Address permission: Neworg   Get Extension String get extension string data    Set Extension String set extension string data permission: Owner    Rationale (optional) #  The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.\nBackwards Compatibility (optional) #  All NEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The NEP must explain how the author proposes to deal with these incompatibilities. NEP submissions without a sufficient backwards compatibility treatise may be rejected outright.\nTest Cases (optional) #  Take the production and sales of new energy vehicles as an example. New energy vehicle manufacturers will have several core suppliers, such as automobile chassis, motor, battery pack and battery management system, automobile glass, etc. The blockchain of new energy vehicles will include its supplier contract, the blockchain of supplier products (automobile chassis, motor, battery pack and battery management system, automobile glass, etc.). The blockchain of new energy vehicles will also be delivered to auto agents or dealers, and finally to consumers.\nImplementation (optional) #  The implementations must be completed before any NEP is given status \u0026ldquo;Final\u0026rdquo;, but it need not be completed before the NEP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \u0026ldquo;rough consensus and running code\u0026rdquo; is still useful when it comes to resolving many discussions of API details.\nSecurity Considerations #  References #  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':36,'href':'/neps/nep-61/','title':"Support Of Batch Mint EVT (NRC-61)",'section':"NEPs",'content':"Simple Summary #  This proposal is an improved implementation of the NRC-53(EVT) that supports minting multiple tokens for close to the cost of one.\nMotivation #  Gas savings is very important for EVT\u0026rsquo;s users. So we propose a fully compliant implementation of NRC-53(EVT) with significant gas savings for minting multiple EVTs in a single transaction. This project and implementation will be updated regularly and will continue to stay up to date with best practices.\nThe network BASEFEE remained low despite huge demand, resulting in low gas costs for minters, while minimizing network disruption for the wider ecosystem as well.\n   Quantity EVT(new) EVTA(new)     1 29.884 28.688   2 44.935 29.6585   3 59.7355 30.629   5 89.3365 32.57   10 163.339 37.4225   50 755.3615 76.2425   100 1495.3945 124.7675   200 2975.4745 221.8175    Specification #  interface IEVTA { struct TokenOwnership { // The address of the owner.  address addr; // Stores the start time of ownership with minimal overhead for tokenomics.  uint64 startTimestamp; // Whether the token has been burned.  bool burned; // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.  uint24 extraData; } /** * @dev Returns the total number of tokens in existence. * Burned tokens will reduce the count. * To get the total number of tokens minted, please see{_totalMinted}. */ function totalSupply() external view returns (uint256); /** * @dev Returns true if this contract implements the interface defined by * `interfaceId`. See the corresponding * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified) * to learn more about how these ids are created. * * This function call must use less than 30000 gas. */ function supportsInterface(bytes4 interfaceId) external view returns (bool); /** * @dev Emitted when `tokenId` token is transferred from `from` to `to`. */ event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); /** * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token. */ event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); /** * @dev Emitted when `owner` enables or disables * (`approved`) `operator` to manage all of its assets. */ event ApprovalForAll(address indexed owner, address indexed operator, bool approved); /** * @dev Returns the number of tokens in `owner`\u0026#39;s account. */ function balanceOf(address owner) external view returns (uint256 balance); /** * @dev Returns the owner of the `tokenId` token. * * Requirements: * * - `tokenId` must exist. */ function ownerOf(uint256 tokenId) external view returns (address owner); /** * @dev Safely transfers `tokenId` token from `from` to `to`, * checking first that contract recipients are aware of the ERC721 protocol * to prevent tokens from being forever locked. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must exist and be owned by `from`. * - If the caller is not `from`, it must be have been allowed to move * this token by either {approve} or {setApprovalForAll}. * - If `to` refers to a smart contract, it must implement * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. * * Emits a {Transfer} event. */ function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data ) external; /** * @dev Equivalent to `safeTransferFrom(from, to, tokenId, \u0026#39;\u0026#39;)`. */ function safeTransferFrom( address from, address to, uint256 tokenId ) external; /** * @dev Transfers `tokenId` from `from` to `to`. * * WARNING: Usage of this method is discouraged, use {safeTransferFrom} * whenever possible. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * * Emits a {Transfer} event. */ function transferFrom( address from, address to, uint256 tokenId ) external; /** * @dev Gives permission to `to` to transfer `tokenId` token to another account. * The approval is cleared when the token is transferred. * * Only a single account can be approved at a time, so approving the * zero address clears previous approvals. * * Requirements: * * - The caller must own the token or be an approved operator. * - `tokenId` must exist. * * Emits an {Approval} event. */ function approve(address to, uint256 tokenId) external; /** * @dev Approve or remove `operator` as an operator for the caller. * Operators can call {transferFrom} or {safeTransferFrom} * for any token owned by the caller. * * Requirements: * * - The `operator` cannot be the caller. * * Emits an {ApprovalForAll} event. */ function setApprovalForAll(address operator, bool _approved) external; /** * @dev Returns the account approved for `tokenId` token. * * Requirements: * * - `tokenId` must exist. */ function getApproved(uint256 tokenId) external view returns (address operator); /** * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`. * * See {setApprovalForAll}. */ function isApprovedForAll(address owner, address operator) external view returns (bool); /** * @dev Emitted when tokens in `fromTokenId` to `toTokenId` * (inclusive) is transferred from `from` to `to`, as defined in the * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309). * * See {_mintERC2309} for more details. */ event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to); } References #  Proposals\n  NEP-53 Encrypted Variable Token Proposal.  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':37,'href':'/neps/nep-56/','title':"URI Format For Universal Storage Mechanism",'section':"NEPs",'content':"Abstract #  This standard defines the URI format for universal storage mechanism. This URI can then be shown either as a QR code or as a link.\nSpecification #  URI Format #   [protocol] :// [?region code/] [parameters]\n Example #  ipfs://rc-1/QmXGPn9JF2v2G5CZexUHjkxFf8so8xgA1hujoWbvc1YJVh\nProtocol #  IPFS, AR, HTTP, BTFS etc.\nRegion code #  These are the template registered region code for usage.\n   Region code Protocol Application Endpoints     rc-1 IPFS MyApp https://ipfs.xxxxx.com    This NEP is not a central directory for the registered region code, please visit AEPs: https://github.com/newtonproject/AEPs/blob/master/AEP-56.md\nCopyright #  Copyright and related rights waived via CC0.\n"});})();